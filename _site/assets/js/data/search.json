[
  
  {
    "title": "React 19장 - Cmarket props drilling",
    "url": "/posts/4-React-Cmarket/",
    "categories": "REACT",
    "tags": "react, components, jsx, state, ui, props, drilling",
    "date": "2023-02-23 00:00:00 +0900",
    





    
    "snippet": "React  장바구니에 상품을 추가하거나 삭제하고,props를 활용하여 총 주문 금액의 상태값이 바뀌는 기능을 구현한다.state.js  state 파일에 임의의 값을 작성해 놓는다.export const initialState = {    \"items\": [        {            \"id\" : 1,            \"name\" : \"...",
    "content": "React  장바구니에 상품을 추가하거나 삭제하고,props를 활용하여 총 주문 금액의 상태값이 바뀌는 기능을 구현한다.state.js  state 파일에 임의의 값을 작성해 놓는다.export const initialState = {    \"items\": [        {            \"id\" : 1,            \"name\" : \"노른자 분리기\",            \"img\" : \"../images/egg.png\",            \"price\" : 9900        },        {            \"id\" : 2,            \"name\" : \"2020년 달력\",            \"img\" : \"../images/2020.png\",            \"price\" : 12000        },        {            \"id\" : 3,            \"name\" : \"개구리 안대\",            \"img\" : \"../images/frog.png\",            \"price\" : 2900        },        {            \"id\" : 4,            \"name\" : \"뜯어온 보도블럭\",            \"img\" : \"../images/block.png\",            \"price\" : 4900        },        {            \"id\" : 5,            \"name\" : \"칼라 립스틱\",            \"img\" : \"../images/lip.png\",            \"price\" : 2900        },        {            \"id\" : 6,            \"name\" : \"잉어 슈즈\",            \"img\" : \"../images/fishegg.png\",            \"price\" : 3900        },        {            \"id\" : 7,            \"name\" : \"웰컴 매드\",            \"img\" : \"../images/welcome.png\",            \"price\" : 6900        },        {            \"id\" : 8,            \"name\" : \"강시 모자\",            \"img\" : \"../images/hat.png\",            \"price\" : 9900        },    ],    \"cartItems\":[        {            \"itemId\" : 1,            \"quantity\" : 1        },        {            \"itemId\" : 5,            \"quantity\" : 7        },        {            \"itemId\" : 2,            \"quantity\" : 3        },    ]}App.js  App 컴포넌트에서 상태값을 작성한다.          하나의 상태값을 여러 컴포넌트에서 공유하기 때문에 상위 컴포넌트에 작성한다.        임의로 작성한 기존값을 받아와, initialState의 items키가 가진 객체들을 상태값인 items에 지정해준다.  임의로 작성한 기존값을 받아와, initialState의 cartItems키가 가진 객체들을 상태값인 cartItems에 지정해준다.  Router을 사용하여 Link에 따른 페이지를 보여준다.  ItemListContainer 컴포넌트에 items,cartItems,setCartItems를 인자로 넘겨준다.          상태값을 설정하는 useState자체를 인자로 넘겨줘서 사용할 수 있다.        ShoppingCart 컴포넌트에도 마찬가지로 인자를 넘겨준다.import React, { useState } from \"react\";import Nav from \"./components/Nav\";import ItemListContainer from \"./pages/ItemListContainer\";import \"./App.css\";import \"./variables.css\";import { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";import ShoppingCart from \"./pages/ShoppingCart\";import { initialState } from \"./assets/state\";function App() {  const [items, setItems] = useState(initialState.items);  const [cartItems, setCartItems] = useState(initialState.cartItems);  return (    &lt;Router&gt;      &lt;Nav cartItems={cartItems} /&gt;      &lt;Routes&gt;        &lt;Route          path=\"/\"          element={            &lt;ItemListContainer              items={items}              cartItems={cartItems}              setCartItems={setCartItems}            /&gt;          }        /&gt;        &lt;Route          path=\"/shoppingcart\"          element={            &lt;ShoppingCart              cartItems={cartItems}              items={items}              setCartItems={setCartItems}            /&gt;          }        /&gt;      &lt;/Routes&gt;      &lt;img        id=\"logo_foot\"        src={`${process.env.PUBLIC_URL}/codestates-logo.png`}        alt=\"logo_foot\"      /&gt;    &lt;/Router&gt;  );}export default App;Nav.js  Nav 컴포넌트는 Link 주솟값을 가진 상품리스트와 장바구니 메뉴를 갖고 있다.  장바구니 메뉴에는 우리가 장바구니에 담은 목록의 갯수만큼 숫자로 보여준다.  App 컴포넌트에서 cartItems를 입력받아, 입력받은 객체의 갯수만큼 보여준다.  cartItems는 state에서 불러온 initialState.cartItems이다.import React from \"react\";import { Link } from \"react-router-dom\";function Nav({ cartItems }) {  return (    &lt;div id=\"nav-body\"&gt;      &lt;span id=\"title\"&gt;        &lt;img id=\"logo\" src=\"../logo.png\" alt=\"logo\" /&gt;        &lt;span id=\"name\"&gt;CMarket&lt;/span&gt;      &lt;/span&gt;      &lt;div id=\"menu\"&gt;        &lt;Link to=\"/\"&gt;상품리스트&lt;/Link&gt;        &lt;Link to=\"/shoppingcart\"&gt;          장바구니&lt;span id=\"nav-item-counter\"&gt;{cartItems.length}&lt;/span&gt;        &lt;/Link&gt;      &lt;/div&gt;    &lt;/div&gt;  );}export default Nav;ItemListContainer.js  App 컴포넌트로부터 items (initialState.items),cartItems (initialState.cartItems),setCartItems를 전달받는다.  전달받은 setCartItems로 App 컴포넌트의 cartItems의 상태값을 변경할 수 있다.  Item 컴포넌트로 App 컴포넌트에서 전달받은 items와 작성된 함수 handleClick을 props로 넘겨준다.  handleClick 함수는 cartItems에 추가될 새로운 배열 newCartItem을 만들고, newCartItem의 itemId 키 값은 Item 컴포넌트에서 클릭 이벤트를 발생한 대상의 id값이 들어간다.  handleClick 함수는 새롭게 작성할 newCartItem의 quantity 키 값에 1을 할당하는데, 그 이유는 for문을 돌려 만약 기존에 cartItems 안에 작성되어 있는 id값과 비교하여 중복되는 경우 갯수인 quantity를 증가시켜주고, 중복되지 않으면 장바구니에 담기지 않았다는 뜻이기에 클릭한 항목 자체를 추가해준다.  setCartItems를 사용하여 새로운 cartItems를 만들어주는 이유는, 리액트는 상태의 주솟값이 변하지 않고 요소들만 바뀔 시, 값이 바뀌지 않았다고 인식하기 때문에 주솟값 자체가 바뀐 새로운 cartItems를 만들어 준다.  return문이 없을 시, 이미 들어간 항목을 기존의 cartItems배열과 함께 추가하여 작성하는 setCartItems([...cartItems, newCartItem])까지 도달하기 때문에 중복된다.import React from \"react\";import Item from \"../components/Item\";function ItemListContainer({ items, cartItems, setCartItems }) {  const handleClick = (e, id) =&gt; {    let newCartItem = {};    newCartItem.itemId = id;    newCartItem.quantity = 1;    console.log(id);    for (let i = 0; i &lt; cartItems.length; i++) {      if (cartItems[i].itemId === id) {        setCartItems([...cartItems]);        cartItems[i].quantity++;        return;      }    }    setCartItems([...cartItems, newCartItem]);  };  return (    &lt;div id=\"item-list-container\"&gt;      &lt;div id=\"item-list-body\"&gt;        &lt;div id=\"item-list-title\"&gt;쓸모없는 선물 모음&lt;/div&gt;        {items.map((item, idx) =&gt; (          &lt;Item item={item} key={idx} handleClick={handleClick} /&gt;        ))}      &lt;/div&gt;    &lt;/div&gt;  );}export default ItemListContainer;Item.js  ItemListContainer 컴포넌트에게 전달받은 item,handleClick을 부여한다.          item은 ItemListContainer에서 기존의 값인 items를 map으로 뿌려준 각각의 객체이다.      button을 클릭 시, 클릭한 대상인 e와 각각의 items의 객체인 item의 id키 값을 handleClick으로 다시 넘겨준다.      handleClick함수의 결괏값이 어디로 가는지에 대해 생각하기보다 함수 자체가 리턴하는 것이 어느 것인지에 초점을 둔다.      handleClick함수는 장바구니에 아이템이 겹치는지를 확인하여 cartItems에 추가한다.      import React from 'react'export default function Item({ item, handleClick }) {  return (    &lt;div key={item.id} className=\"item\"&gt;      &lt;img className=\"item-img\" src={item.img} alt={item.name}&gt;&lt;/img&gt;      &lt;span className=\"item-name\"&gt;{item.name}&lt;/span&gt;      &lt;span className=\"item-price\"&gt;{item.price}&lt;/span&gt;      &lt;button className=\"item-button\" onClick={() =&gt; handleClick(item.id)}&gt;장바구니 담기&lt;/button&gt;    &lt;/div&gt;  )}ShoppingCart.js  App 컴포넌트에서 ShoppingCart 컴포넌트로 items,cartItems,setCartItems를 넘겨준다.  checkedItems상태는 입력받은 cartItems의 각 객체의 itemId를 갖고 있다.  handleCheckChange,handleQuantityChange,handleDelete 함수는 CartItem 컴포넌트에게 props로 전달해준다.  CartItem 컴포넌트에게 전달된 handleCheckChange는 input의 checkbox를 클릭했을 때 발생하는 대상의 checked여부와 items의 id를 넘겨준다.          만약 checked가 된 상태라면 cartItems의 itemdId를 map한 상태인 checkedItems에 전달받은 item.id(선택한 상품의 id)를 추가해준다.      만약 선택한 체크 박스가 해제된 상태면 filter를 통해 선택한 상품의 id가 일치하는 항목을 checkedItems에서 빼준다.            handleAllCheck 함수는 ShoppingCart의 input요소를 누르면 발생하며, 체크 박스가 선택된 상태라면 cartItems의 id를 checkedItems상태에 모두 담아주며 체크 박스의 선택을 해제한 상태라면 checkedItems를 모두 비워준다.    handleQuantityChange를 CartItem 컴포넌트에게 전달하여 숫자를 조절하는 input요소에 전달한다.          이벤트를 발생시킨 요소의 value값인 quantity와 items를 filter한 item의 id를 함수의 인자로 넘겨준다.      만약 cartItems의 요소 중 itemId 키 값과 우리가 전달받은 filter한 item id가 일치하면, 일치하는 요소의 quantity를 우리가 input으로 입력한 숫자로 설정해준다.      우리가 조작한 숫자로 quantity를 설정한다.        handleDelete 또한 CartItem 컴포넌트에게 전달하여 선택한 요소의 id를 전달인자로 받는다.          전달인자로 입력받은 id를 cartItems.filter를 통해 일치하는 id를 cartItems에서 제외한다.      장바구니에서 삭제한다.        getTotal 함수는 cartItems의 itemsId를 가진 새로운 배열을 갖고 있는 cartIdArr를 선언한다.          checkedItems에 cartIdArr가 있을 경우 cartIdArr의 수량을 total의 quantity에 더해준다.                  총 수량 갯수 구하기                    가격은 items를 filter 하여 cartIdArr가 가르키는 id와 일치하는 상품의 가격을 받아와 total의 price에 더해준다.                  총 주문 금액 구하기                      renderItems 함수는 items를 filter하여 items의 id와 cartItems의 요소의 id를 비교해서 index 값이 -1보다 크다는 것은 값이 있다는 말이기 때문에 items의 요소를 남긴다.          renderItems는 카트에 들어가 있는 요소 들이고, 이 renderItems를 다시 map으로 돌리는데 갯수는 cartItems에서 일치하는 id를 가진 상품의 갯수로 할당해준다.      할당된 qauntity를 CartItem 컴포넌트에 넘겨준다.      import React, { useState } from \"react\";import CartItem from \"../components/CartItem\";import OrderSummary from \"../components/OrderSummary\";export default function ShoppingCart({ items, cartItems, setCartItems }) {  const [checkedItems, setCheckedItems] = useState(    cartItems.map((el) =&gt; el.itemId)  );  const handleCheckChange = (checked, id) =&gt; {    if (checked) {      setCheckedItems([...checkedItems, id]);    } else {      setCheckedItems(checkedItems.filter((el) =&gt; el !== id));    }  };  const handleAllCheck = (checked) =&gt; {    if (checked) {      setCheckedItems(cartItems.map((el) =&gt; el.itemId));    } else {      setCheckedItems([]);    }  };  const handleQuantityChange = (quantity, itemId) =&gt; {    setCartItems(      cartItems.map((el) =&gt; {        if (el.itemId === itemId) {          el.quantity = quantity;        }        return el;      })    );  };  const handleDelete = (itemId) =&gt; {    console.log(itemId);    setCartItems(cartItems.filter((el) =&gt; el.itemId !== itemId));  };  const getTotal = () =&gt; {    let cartIdArr = cartItems.map((el) =&gt; el.itemId);    let total = {      price: 0,      quantity: 0,    };    for (let i = 0; i &lt; cartIdArr.length; i++) {      if (checkedItems.indexOf(cartIdArr[i]) &gt; -1) {        let quantity = cartItems[i].quantity;        let price = items.filter((el) =&gt; el.id === cartItems[i].itemId)[0]          .price;        total.price = total.price + quantity * price;        total.quantity = total.quantity + quantity;      }    }    return total;  };  const renderItems = items.filter(    (el) =&gt; cartItems.map((el) =&gt; el.itemId).indexOf(el.id) &gt; -1  );  const total = getTotal();  return (    &lt;div id=\"item-list-container\"&gt;      &lt;div id=\"item-list-body\"&gt;        &lt;div id=\"item-list-title\"&gt;장바구니&lt;/div&gt;        &lt;span id=\"shopping-cart-select-all\"&gt;          &lt;input            type=\"checkbox\"            checked={checkedItems.length === cartItems.length ? true : false}            onChange={(e) =&gt; handleAllCheck(e.target.checked)}          &gt;&lt;/input&gt;          &lt;label&gt;전체선택&lt;/label&gt;        &lt;/span&gt;        &lt;div id=\"shopping-cart-container\"&gt;          {!cartItems.length ? (            &lt;div id=\"item-list-text\"&gt;장바구니에 아이템이 없습니다.&lt;/div&gt;          ) : (            &lt;div id=\"cart-item-list\"&gt;              {renderItems.map((item, idx) =&gt; {                const quantity = cartItems.filter(                  (el) =&gt; el.itemId === item.id                )[0].quantity;                return (                  &lt;CartItem                    key={idx}                    handleCheckChange={handleCheckChange}                    handleQuantityChange={handleQuantityChange}                    handleDelete={handleDelete}                    item={item}                    checkedItems={checkedItems}                    quantity={quantity}                  /&gt;                );              })}            &lt;/div&gt;          )}          &lt;OrderSummary total={total.price} totalQty={total.quantity} /&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  );}"
  },
  
  {
    "title": "React 18장 - 상태관리",
    "url": "/posts/3-React-Redux-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC/",
    "categories": "REACT",
    "tags": "react, components, jsx, state, ui, props",
    "date": "2023-02-23 00:00:00 +0900",
    





    
    "snippet": "React상태  프론트엔드 개발에서 UI에 동적으로 표현될 데이터를 말한다.  예를 들어, 쇼핑몰의 장바구니 안에는 상품의 선택 여부, 선택한 상품의 수량, 장바구니에 담긴 물품, 선택한 물품에 따른 주문 금액 등이 변할 수 있는 상태이다.  상태에 따라 어떤 화면이 영향을 받고, 이 화면을 컴포넌트로 분리하여 컴포넌트가 서로 어떠한 상태를 공유하고 ...",
    "content": "React상태  프론트엔드 개발에서 UI에 동적으로 표현될 데이터를 말한다.  예를 들어, 쇼핑몰의 장바구니 안에는 상품의 선택 여부, 선택한 상품의 수량, 장바구니에 담긴 물품, 선택한 물품에 따른 주문 금액 등이 변할 수 있는 상태이다.  상태에 따라 어떤 화면이 영향을 받고, 이 화면을 컴포넌트로 분리하여 컴포넌트가 서로 어떠한 상태를 공유하고 주고받는다.예시  상태는 크게 두 가지로 나눌 수 있는데, 특정 컴포넌트 안에서만 관리되는 로컬상태, 전체 혹은 여러 가지 컴포넌트가 동시에 관리하는 전역 상태가 있다.          장바구니 예시      로컬 상태의 예시는 선택한 수량이 있다.                  원래 가격에 상태를 곱해 컴포넌트 내에 표시만 해주면 되고, 다른 컴포넌트와 데이터를 공유하지 않는 form을 가지는 input box,select box를 에로 들 수 있다.                    전역 상태의 에시는 총 주문 금액이 있다.                  상품 선택 여부에 따라 총 주문을 업데이트해야 하기에 장바구니에 담긴 물품이 그 갯수를 다른 컴포넌트에 전달해 주어야 한다.          또한 장바구니 데이터를 서버에서 받아와야 한다면 API를 호출해야 하고, 데이터의 전송 여부에 따라 로딩 여부를 나타낼 것인지도 고려해야 한다.          API를 사용하는 것도 side effect를 발생시키며 로딩 여부 상태도 전역 상태로 볼 수 있다.                      서로 다른 컴포넌트가 사용하는 상태의 종류가 다르다면 꼭 전역 상태일 필요는 없지만, 서로 다른 컴포넌트가 동일한 상태를 다룬다면 출처는 오직 한 곳이어야 한다.          만일 사본이 있을 경우, 두 데이터는 동기화 과정이 필요한데, 이는 문제를 복잡하게 만들기 떄문에 한 곳에서만 상태를 저장하고 접근해야한다.        데이터의 무결성을 위해 동일한 데이터는 항상 같은 곳에서 데이터를 가지고 와야하며, Single source of truth(신뢰할 수 있는 단일 출처) 원칙을 지켜야 한다.          데이터가 존재하고 데이터를 보여줘야 하는 우리의 의도와 다른 예외 상황이 없도록 해야 한다.        다크 모드의 경우, 모든 페이지, 모든 컴포넌트에 다크 모드 혹은 라이트 모드가 적용 되어야 하기 때문에 테마 설정을 전역으로 관리하는 것을 예로 들 수 있다.상태 관리를 위한 툴  React Context  Redux  MobX  상태 관리를 위한 툴은, props drilling(프로퍼티 내려꽂기)문제를 해결해준다.          A 라는 컴포넌트에 상태가 있고, 마지막 컴포넌트인 I 라는 컴포넌트가 해당 상태를 사용한다면, 중간에 위치한 C, G 컴포넌트는 A의 name이라는 상태가 필요하지 않음에도 컴포넌트에 props를 만들어 자식 컴포넌트에 넘겨주어야 하는 문제점이다.        상태 관리 툴은 필요에 따라 사용되며, 꼭 필요한 툴은 아니다.Props Drilling  상위 컴포넌트에서 하위 컴포넌트로 state를 전달하고자 할 때, 상태값을 props를 통해 전달하는 용도로만 쓰이는 형상을 말한다.  전달 횟수가 6회 이내로 많지 않다면 큰 문제가 되지 않지만, 규모가 커지고 복잡해지며 문제가 발생한다.          코드의 가독성이 매우 나빠진다.      코드의 유지보수 또한 힘들어진다.      state변경 시 props전달 과정에서 불필요하게 관여된 컴포넌트들 또한 re-render되야 하기 때문에 웹 성능에 악영향을 준다.      해결 방법  과도한 props drilling을 방지하기 위해 컴포넌트와 관련있는 state는 될 수 있으면 가까이 유지하는 방법과 상태관리 라이브러리를 사용하는 방법이 있다.  상태관리 라이브러리를 사용하게 되면 전역으로 관리하는 저장소에서 직접 state를 꺼내쓸 수 있기 때문에 props drilling을 방지하기에 매우 효과적이다.예시  props drilling  상위 컴포넌트에서 하위 컴포넌트로 props 끝까지 전달해준다.  StackBlitz로 보기import React, { useState } from 'react';import styled from 'styled-components';const Container = styled.div`  border: 5px solid green;  padding: 10px;  margin: 10px;  position: relative;`;const Quantity = styled.div`  text-align: center;  color: red;  border: 5px solid red;  padding: 3px;  font-size: 1.2rem;`;const Button = styled.button`  margin-right: 5px;`;const Text = styled.div`  color: ${(props) =&gt; (props.color ? props.color : 'black')};  font-size: ${(props) =&gt; (props.size ? props.size : '1rem')};  font-weight: ${(props) =&gt; (props.weight ? '700' : 'inherit')};`;export default function App() {  const [number, setNumber] = useState(1);  const plusNum = () =&gt; {    setNumber(number + 1);  };  const minusNum = () =&gt; {    setNumber(number - 1);  };  console.log('Parents');  return (    &lt;Container&gt;      &lt;Text weight size=\"1.5rem\"&gt;        [Parents Component]      &lt;/Text&gt;      &lt;Text&gt;        Child4 컴포넌트에 있는 버튼을 통해        &lt;br /&gt; state를 변경하려고 합니다.. 🤮      &lt;/Text&gt;      &lt;Text weight color=\"tomato\"&gt;        Props Driling이 발생!!      &lt;/Text&gt;      &lt;Quantity&gt;{`수량 : ${number}`}&lt;/Quantity&gt;      &lt;Child1 plusNum={plusNum} minusNum={minusNum} /&gt;    &lt;/Container&gt;  );}function Child1(  {    /* props로 전달받은 plusNum, minusNum를 가져오세요 */  }) {  console.log('Child1');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 1 Component]&lt;/Text&gt;      {/* plusNum, minusNum 함수를 props로 전달해주세요! */}      &lt;Child2 /&gt;    &lt;/Container&gt;  );}function Child2(  {    /* props로 전달받은 plusNum, minusNum를 가져오세요 */  }) {  console.log('Child2');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 2 Component]&lt;/Text&gt;      {/* plusNum, minusNum 함수를 props로 전달해주세요! */}      &lt;Child3 /&gt;    &lt;/Container&gt;  );}function Child3(  {    /* props로 전달받은 plusNum, minusNum를 가져오세요 */  }) {  console.log('Child3');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 3 Component]&lt;/Text&gt;      {/* plusNum, minusNum 함수를 props로 전달해주세요! */}      &lt;Child4 /&gt;    &lt;/Container&gt;  );}function Child4({ plusNum, minusNum }) {  console.log('Child4');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 4 Component]&lt;/Text&gt;      &lt;Button onClick={plusNum}&gt;👍&lt;/Button&gt;      &lt;Button onClick={minusNum}&gt;👎&lt;/Button&gt;    &lt;/Container&gt;  );}  라이브러리 사용 예시  StackBlitz로 보기import React, { useState } from 'react';import styled from 'styled-components';import { useSelector, useDispatch } from 'react-redux';const Container = styled.div`  border: 5px solid green;  padding: 10px;  margin: 10px;  position: relative;`;const Quantity = styled.div`  text-align: center;  color: red;  border: 5px solid red;  padding: 3px;  font-size: 1.2rem;`;const Button = styled.button`  margin-right: 5px;`;const Text = styled.div`  color: ${(props) =&gt; (props.color ? props.color : 'black')};  font-size: ${(props) =&gt; (props.size ? props.size : '1rem')};  font-weight: ${(props) =&gt; (props.weight ? '700' : 'inherit')};`;export default function App() {  const number = useSelector((state) =&gt; state);  console.log('Parents');  return (    &lt;Container&gt;      &lt;Text weight size=\"1.5rem\"&gt;        [Parents Component]      &lt;/Text&gt;      &lt;Text&gt;        Child4 컴포넌트에 있는 버튼을 통해 &lt;br /&gt; state를 변경하려고 합니다. ☺️      &lt;/Text&gt;      &lt;Text weight color=\"tomato\"&gt;        (Redux를 사용하는 경우)      &lt;/Text&gt;      &lt;Quantity&gt;{`수량 : ${number}`}&lt;/Quantity&gt;      &lt;Child1 /&gt;    &lt;/Container&gt;  );}function Child1() {  console.log('Child1');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 1 Component]&lt;/Text&gt;      &lt;Child2 /&gt;    &lt;/Container&gt;  );}function Child2() {  console.log('Child2');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 2 Component]&lt;/Text&gt;      &lt;Child3 /&gt;    &lt;/Container&gt;  );}function Child3() {  console.log('Child3');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 3 Component]&lt;/Text&gt;      &lt;Child4 /&gt;    &lt;/Container&gt;  );}function Child4() {  const dispatch = useDispatch();  const plusNum = () =&gt; {    dispatch({ type: 'Plus' });  };  const minusNum = () =&gt; {    dispatch({ type: 'Minus' });  };  console.log('Child4');  return (    &lt;Container&gt;      &lt;Text&gt;[Child 4 Component]&lt;/Text&gt;      &lt;Button onClick={plusNum}&gt;👍&lt;/Button&gt;      &lt;Button onClick={minusNum}&gt;👎&lt;/Button&gt;    &lt;/Container&gt;  );}예시 2  느낌표가 하나씩 추가되는 애플리케이션  Child3, Child6는 하나의 상태를 공유하기 때문에 최상위 컴포넌트인 App에서 사애를 관리한다.  따라서, 상태가 변경될 때마다 App 컴포넌트가 re-render되며 모든 컴포넌트가 re-render된다.  StackBlitz로 보기import * as React from 'react';import './style.css';import styled from 'styled-components';import { useState } from 'react';const Component = styled.div`  border: 3px solid green;  border-radius: 10px;  flex-grow: 1;  line-height: 30px;  text-align: center;  margin: 10px;  &gt;button{    margin-left: 10px;  }`;const Container = styled.div`  display: flex;  width: 100%;  justify-contents: center;`;export default function App() {  const [greeting, setGreeting] = useState('Hello');  console.log('App');  return (    &lt;Container&gt;      &lt;Component&gt;        App        &lt;Container&gt;          &lt;Child1 greeting={greeting} setGreeting={setGreeting} /&gt;          &lt;Child2 greeting={greeting} setGreeting={setGreeting} /&gt;        &lt;/Container&gt;      &lt;/Component&gt;    &lt;/Container&gt;  );}function Child1({ greeting, setGreeting }) {  console.log('Child1');  return (    &lt;Component&gt;      Child1      &lt;Container&gt;        &lt;Child3 greeting={greeting} setGreeting={setGreeting} /&gt;        &lt;Child4 /&gt;      &lt;/Container&gt;    &lt;/Component&gt;  );}function Child2({ greeting, setGreeting }) {  console.log('Child2');  return (    &lt;Component&gt;      Child2      &lt;Container&gt;        &lt;Child5 /&gt;        &lt;Child6 greeting={greeting} setGreeting={setGreeting} /&gt;      &lt;/Container&gt;    &lt;/Component&gt;  );}function Child3({ greeting, setGreeting }) {  console.log('Child3');  return &lt;Component&gt;Child3 : {greeting} &lt;/Component&gt;;}function Child4() {  console.log('Child4');  return &lt;Component&gt;Child4&lt;/Component&gt;;}function Child5() {  console.log('Child5');  return &lt;Component&gt;Child5&lt;/Component&gt;;}function Child6({ greeting, setGreeting }) {  console.log('Child6');  return (    &lt;Component&gt;      Child6      &lt;button onClick={() =&gt; setGreeting(greeting + '!')}&gt;👋&lt;/button&gt;    &lt;/Component&gt;  );}  라이브러리 사용 예시  StackBlitz로 보기import * as React from 'react';import './style.css';import styled from 'styled-components';import { useSelector, useDispatch } from 'react-redux';const Component = styled.div`  border: 3px solid green;  border-radius: 10px;  flex-grow: 1;  line-height: 30px;  text-align: center;  margin: 10px;  &gt;button{    margin-left: 10px;  }`;const Container = styled.div`  display: flex;  width: 100%;  justify-contents: center;`;export default function App() {  console.log('App');  return (    &lt;Container&gt;      &lt;Component&gt;        App        &lt;Container&gt;          &lt;Child1 /&gt;          &lt;Child2 /&gt;        &lt;/Container&gt;      &lt;/Component&gt;    &lt;/Container&gt;  );}function Child1() {  console.log('Child1');  return (    &lt;Component&gt;      Child1      &lt;Container&gt;        &lt;Child3 /&gt;        &lt;Child4 /&gt;      &lt;/Container&gt;    &lt;/Component&gt;  );}function Child2() {  console.log('Child2');  return (    &lt;Component&gt;      Child2      &lt;Container&gt;        &lt;Child5 /&gt;        &lt;Child6 /&gt;      &lt;/Container&gt;    &lt;/Component&gt;  );}function Child3() {  const greeting = useSelector((state) =&gt; state);  console.log('Child3');  return &lt;Component&gt;Child3 : {greeting} &lt;/Component&gt;;}function Child4() {  console.log('Child4');  return &lt;Component&gt;Child4&lt;/Component&gt;;}function Child5() {  console.log('Child5');  return &lt;Component&gt;Child5&lt;/Component&gt;;}function Child6() {  console.log('Child6');  const dispatch = useDispatch();  const addBang = () =&gt; {    dispatch({ type: 'AddBang' });  };  return (    &lt;Component&gt;      Child6      &lt;button onClick={addBang}&gt;👋&lt;/button&gt;    &lt;/Component&gt;  );}"
  },
  
  {
    "title": "Algorithm 5장 - 시간복잡도와 공간복잡도",
    "url": "/posts/2-Algorithm-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%99%80-%EA%B3%B5%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/",
    "categories": "ALGORITHM",
    "tags": "algorithm",
    "date": "2023-02-23 00:00:00 +0900",
    





    
    "snippet": "Algorithm알고리즘의 성능 평가  어떤 알고리즘이 있을 때, 알고리즘의 성능을 평가하기 위해 사용하는 척도이다.  그 중 시간 복잡도와 공간 복잡도가 있는데, 동일한 기능을 수행하는 알고리즘이 있을 때 복잡도가 낮을 수록 좋은 알고리즘이라고 한다.          시간 복잡도 : 특정한 크기의 입력에 대한 알고리즘의 수행 시간 분석      공간...",
    "content": "Algorithm알고리즘의 성능 평가  어떤 알고리즘이 있을 때, 알고리즘의 성능을 평가하기 위해 사용하는 척도이다.  그 중 시간 복잡도와 공간 복잡도가 있는데, 동일한 기능을 수행하는 알고리즘이 있을 때 복잡도가 낮을 수록 좋은 알고리즘이라고 한다.          시간 복잡도 : 특정한 크기의 입력에 대한 알고리즘의 수행 시간 분석      공간 복잡도 : 특정한 크기의 입력에 대한 알고리즘의 메모리 사용량 분석      시간 복잡도  시간 복잡도는 특정 알고리즘이 어떤 문제를 해결하는 데 걸리는 시간을 의미한다.  같은 결과를 갖는 프로그래밍도 작성 방법에 따라 걸리는 시간이 다르며, 시간이 적게 걸리는 것이 좋다.빅-오 표기법  시간 복잡도에는 빅-오 표기법이 있다.  통전을 튕겨 뒷면이 나올 확률은 첫 번째에 바로 나올 확률도 있지만, 운이 없는 경우에 n번만큼 던져야 하는 경우도 있다.      이 때 n번만큼 던지는 최악의 경우의 수를 계산하는 방식을 빅-오(Big-O) 표기법이라 부른다.          O(1)                  Constant          입력 데이터의 크기와 상관없이 언제나 일정한 시간이 걸리는 알고리즘이다.          데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다.                    O(log₂ n)                  Logarithmic          입력 데이터의 크기가 커질수록 처리 시간이 로그만큼 짧아지는 알고리즘이다.          예를 들어, 데이터의 크기가 10배가 되면, 처리 시간은 2배가 된다.          이진 탐색이 대표적이며, 재귀가 순기능으로 이루어지는 경우에 해당한다.                    O(n)                  Linear          입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다.          예를 들어, 데이터의 크기가 10배가 되면 처리 시간도 10배가 된다.          1차원 for문이 있다.                    O(n log₂ n)                  Linear-Logarithmic          데이터가 많아질수록 처리시간이 로그 배만큼 늘어나는 알고리즘이다.          예를 들어, 데이터의 크기가 10배가 되면 처리 시간은 20배가 된다.          정렬 알고리즘 중 병합 정렬, 퀵 정렬이 대표적이다.                    O(n²)                  데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘이다.          예를 들어, 데이터의 크기가 10배가 되면 처리 시간은 최대 100배가 된다.          이중 루프가 대표적이며 m이 n보다 작을 때는 반드시 O(nm)으로 표시하는 것이 바람직하다.                    O(2ⁿ)                  데이터가 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘이다.          피보나치 수열, 재귀가 역기능을 할 경우가 대표적이다.                    fast O(1) &lt; O(log n) &lt; O(nlog n) &lt; O(n²) &lt; O(2ⁿ) slow 표기법 예제   O(1) : Push, Pop   O(log n) : 이진트리   O(n) : for 문   O(n log n) : 퀵 정렬, 병합정렬, 힙 정렬   O(n²) : 이중 for 문, 삽입정렬, 거품정렬, 선택정렬   O(2ⁿ) : 피보나치 수열공간 복잡도  일반적으로 공간이 하나 생성되는 것을 1이라고 표현한다.  이를 O(1)로 표기한다.          반복문이 N번만큼 반복해도 for문 안에서의 지역변수이므로 공간 복잡도는 여전히 O(1)이다.      다른 것은 전혀 영향을 주지 않는다.        재귀함수일 경우          함수의 매개변수 n에 따라 공간 복잡도가 달라진다.      함수 내부에서 n이 1일 때까지 팩토리얼을 구하는 함수가 재귀적으로 호출되므로 스택에는 n부터 1까지 모두 쌓이며 공간 복잡도는 O(n)이 된다.      공간 복잡도를 줄이는 방법  공간 복잡도를 결정하는 것은 보통 배열의 크기가 몇인지, 얼마만큼 동적할당되는지, 몇 번의 호출을 하는 재귀 함수인지 등이 공간 복잡도에 영향을 끼친다.  프로그램에 필요한 공간은 고정 공간과 가변 공간으로 나뉜다.  함수 호출 시 할당되는 지역변수들이나 동적 할당되는 객체들도 모두 공간이 필요하다.  특히 재귀 함수의 경우 매 함수 호출마다 함수의 매개변수, 지역변수, 함수의 복귀 주소를 저장할 공간이 필요해서 재귀적으로 짤 수도 있고, 반복문으로도 짤 수 있는 경우에는 반복문으로 짜는 것이 더 효율적이다."
  },
  
  {
    "title": "Programers 1장 - Lv.0 외계어 사전",
    "url": "/posts/1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-Lv.0-%EC%99%B8%EA%B3%84%EC%96%B4-%EC%82%AC%EC%A0%84/",
    "categories": "PROGRAMERS",
    "tags": "programers",
    "date": "2023-02-23 00:00:00 +0900",
    





    
    "snippet": "외계어 사전문제  PROGRAMMERS-962 행성에 불시착한 우주비행사 머쓱이는 외계행성의 언어를 공부하려고 합니다.  알파벳이 담긴 배열 spell과 외계어 사전 dic이 매개변수로 주어집니다.  spell에 담긴 알파벳을 한번씩만 모두 사용한 단어가 dic에 존재한다면 1, 존재하지 않는다면 2를 return하도록 solution 함수를 완성해주...",
    "content": "외계어 사전문제  PROGRAMMERS-962 행성에 불시착한 우주비행사 머쓱이는 외계행성의 언어를 공부하려고 합니다.  알파벳이 담긴 배열 spell과 외계어 사전 dic이 매개변수로 주어집니다.  spell에 담긴 알파벳을 한번씩만 모두 사용한 단어가 dic에 존재한다면 1, 존재하지 않는다면 2를 return하도록 solution 함수를 완성해주세요.function solution(spell, dic) {    }제한사항  spell과 dic의 원소는 알파벳 소문자로만 이루어져있습니다.  2 ≤ spell의 크기 ≤ 10  spell의 원소의 길이는 1입니다.  1 ≤ dic의 크기 ≤ 10  1 ≤ dic의 원소의 길이 ≤ 10  spell의 원소를 모두 사용해 단어를 만들어야 합니다.  spell의 원소를 모두 사용해 만들 수 있는 단어는 dic에 두 개 이상 존재하지 않습니다.  dic과 spell 모두 중복된 원소를 갖지 않습니다.입출력 예시            spell      dic      result                  [“p”, “o”, “s”]      [“sod”, “eocd”, “qixm”, “adio”, “soo”]      2              [“z”, “d”, “x”]      [“def”, “dww”, “dzx”, “loveaw”]      1              [”s”, “o”, “m”, “d”]      [“moos”, “dzx”, “smm”, “sunmmo”, “som”]      2      입출력 예 설명  “p”, “o”, “s” 를 조합해 만들 수 있는 단어가 dic에 존재하지 않습니다. 따라서 2를 return합니다.  “z”, “d”, “x” 를 조합해 만들 수 있는 단어 “dzx”가 dic에 존재합니다. 따라서 1을 return합니다.  ”s”, “o”, “m”, “d” 를 조합해 만들 수 있는 단어가 dic에 존재하지 않습니다. 따라서 2을 return합니다.유의사항  입출력 예 #3 에서 “moos”, “smm”, “som”도 “s”, “o”, “m”, “d” 를 조합해 만들 수 있지만 spell의 원소를 모두 사용해야 하기 때문에 정답이 아닙니다.내가 짠 코드function solution(spell, dic) {    let count = true    let num = 0        for(let i=0; i &lt; dic.length; i++){        for(let j=0; j&lt;spell.length; j++){            if(!dic[i].includes(spell[j])){                count = count &amp;&amp; false            }        }        if(count !== false) num++        count = true    }        if(num !== 0) return 1    else return 2    }코드 설명  for문을 반복하여 dic안의 문자열에 spell이 들어가 있는지 확인한다.  만약 spell이 하나라도 들어가 있지 않다면 count에 논리연산자(&amp;&amp;)를 사용하여 false를 대입한다.  count가 false가 아니라면, dic안에 spell 전부 포함되어 있다는 말이기 때문에 num에 숫자 1을 더하고 다시 count=false로 만든다.  반복문을 종료했을 때, num !== 0이라는 말은 문자(spell)을 조합하여 dic를 하나라도 만들 수 있다는 뜻이기 때문에 1을 출력하고, 0이라면 2를 출력한다."
  },
  
  {
    "title": "React 17장 - ClickToEdit 기능",
    "url": "/posts/3-React-styled-component-ClickToEdit/",
    "categories": "REACT",
    "tags": "react, components, jsx, styled-components, clicktoedit",
    "date": "2023-02-22 00:00:00 +0900",
    





    
    "snippet": "ReactClickToEdit  값을 입력했을 때에 정해진 요소의 값을 입력한 값으로 바꿔주는 기능 구현컴포넌트 짜기  입력할 컴포넌트와 입력을 출력할 컴포넌트로 나눈다.  나머지는 styled-component로 감싸준다.return (    &lt;&gt;        &lt;InputView&gt;            &lt;MyInput /&g...",
    "content": "ReactClickToEdit  값을 입력했을 때에 정해진 요소의 값을 입력한 값으로 바꿔주는 기능 구현컴포넌트 짜기  입력할 컴포넌트와 입력을 출력할 컴포넌트로 나눈다.  나머지는 styled-component로 감싸준다.return (    &lt;&gt;        &lt;InputView&gt;            &lt;MyInput /&gt;        &lt;/InputView&gt;        &lt;InputView&gt;            &lt;MyInput /&gt;        &lt;/InputView&gt;        &lt;InputView&gt;            &lt;MyInput /&gt;        &lt;/InputView&gt;    &lt;/&gt;)Styled-Components  InputBox, InputEdit, InputView 컴포넌트로 하위 요소들을 정렬해준다.export const InputBox = Styled.div`    text-align: center;    display: inline-block;    width: 150px;    height: 30px;    border: 1px #bbb dashed;    border-radius: 10px;    margin-left: 1rem;`export const InputEdit = styled.div`    text-align: center;    display: inline-block;    width: 150px;    height: 30px;`export const InputView = styled.div`    text-align: center;    align-items: center;    margin-top: 3rem;    div.view{        margin-top: 3rem;    }`기능 구현상태값 작성  useRef로 요소를 선택한다.  isEditMode로 값을 수정할 수 있는 상태를 만든다.  newValue로 입력될 값을 지정한다.  useEffect를 사용하여 isEditMode,value의 상태값이 변할 때마다 re-render 한다.const inputEl = useRef(null);const [isEditMode, setEditMode] = useState(false)const [newValue, setNewValue] = useState(value)useEffect(()=&gt;{    if(isEditMode){        inputEl.current.focus()    }}, [isEditMode])useEffect(()=&gt;{    setNewValue(value)},[value])컴포넌트에 이벤트 핸들러 부여  handleClick함수로 입력하고 있는 상태를 알려주기 위해 setEditMode를 true와 false로 바꿔주는 역할을 한다.  handleBlur함수로 마우스의 선택이 벗어났을 때 발생시키며, 마우스가 벗어난 상태를 저장하고 setEditMode(false) 입력한 값을 newValue의 상태로 바꾼다.  handleInputChange함수로 input에서 입력한 value값을 newValue에 저장한다.const handleClick = () =&gt; {    setEditMode(!isEditMode)}const handleBlur = () =&gt; {    setEditMode(false)    handleValueChange(newValue)}const handleInputChange = (e) =&gt; {    setNewValue(e.target.value)}코드  InputBox 컴포넌트는 div를 갖고, InputEdit 컴포넌트는 input요소를, InputView 컴포넌트는 div를 갖는다.  ClickToEdit 컴포넌트를 먼저 보면, ClickToEdit 컴포넌트는 InputView와 MyInput 두 가지 컴포넌트를 갖고 있다.  InputView 컴포넌트는 div 요소를 갖고 MyInput 컴포넌트는 value값과 handleValueChange  함수를 인자로 받는다.  MyInput 컴포넌트 안의 handleValueChange 함수는 e를 인자로 받는데, 이 인자는 ClickToEdit 컴포넌트에서 인자로 받은 newValue =&gt; setName(newValue)이다.  handleValueChange 함수는 setNewValue를 통해 MyInput 컴포넌트의 newValue값을 ClickToEdit 컴포넌트의 MyInput으로 전달받은 입력값으로 상태를 변경한다.  useEffect를 통해 re-render한다.  ClickToEdit 컴포넌트의 MyInput 컴포넌트로 전달받은 value 인자는, 기존의 name값을 뜻하는데, MyInput 컴포넌트의 newValue는 name을 초기값으로 갖고 있다.  이제 MyInput 컴포넌트를 들여다보면 isEditMode가 거짓일 때, span태그를 보여주고 newValue를 갖고 있다.          span태그의 newValue는 초기값인, ClickToEdit 컴포넌트로부터 받은 value인 name이다.        span태그를 클릭 시 handleClick 함수를 실행시킨다.          handleClick 함수는 setEditMode를 통해 isEditMode를 true값으로 바꾸는데,useEffect에 의해 isEditMode가 참이기 때문에 inputEl로 설정해 준 input태그를 focus해준다.        isEditMode가 true 값으로 바뀌면 return문을 통해 InputEdit 컴포넌트를 갖게 된다.  InputEdit 컴포넌트는 input태그를 갖고 있으며, input태그 안에 값을 입력할 때마다 onChange={handleInputChange}가 실행되어, handleInputChange 함수가 newValue상태값을 setNewValue를 통해 event를 발생시킨 현재의 target의 value값으로 바꿔준다.  input태그가 아닌 다른 곳을 클릭할 시, focus가 풀리면서 이벤트 핸들러인 onBlur가 실행되고 handleBlur함수를 실행시킨다.          handleBlur에 의해 isEditMode의 상태는 false로 바뀌고 ClickToEdit 컴포넌트의 handleValueChange를 역으로 실행시켜 우리가 입력한 값을 newValue의 값으로 갖게 한다.      isEditMode의 상태가 false로 바뀌었기 때문에 다시 span태그를 생성하여 입력할 input이 대체되게 된다.      import {useState, useEffect, useRef} from \"react\"import styled from \"styled-components\"export const InputBox = styled.div`    text-align: center;    display: inline-block;    width: 150px;    height: 30px;    border: 1px #bbb dashed;    border-radius: 10px;    margin-left: 1rem;`export const InputEdit = styled.input`    text-align: center;    display: inline-block;    width: 150px;    height: 30px;`export const InputView = styled.div`    text-align: center;    align-items: center;    margin-top: 3rem;    div.view{        margin-top: 3rem;    }`export const MyInput = ({value, handleValueChange}) =&gt; {    const inputEl = useRef(null);    const [isEditMode, setEditMode] = useState(false);    const [newValue, setNewValue] = useState(value);    useEffect(()=&gt;{        if(isEditMode){            inputEl.current.focus();        }    },[isEditMode])    useEffect(()=&gt;{        setNewValue(value)    },[value])    const handleClick = () =&gt; {        setEditMode(!isEditMode)    }    const handleBlur = () =&gt; {        setEditMode(false)    }    const handleInputChange = (e) =&gt; {        setNewValue(e.target.value)    }    return (        &lt;InputBox&gt;            {isEditMode ? (                &lt;InputEdit                    type=\"text\"                    value={newValue}                    ref={inputEl}                    onBlur={handleBlur}                    onChange={handleInputChange}                /&gt;            ):(                &lt;span onClick={handleClick}&gt;{newValue}&lt;/span&gt;            )}        &lt;/InputBox&gt;    )}const cache = {    name: \"김코딩\",    age: 20}export const ClickToEdit = () =&gt; {    const [name, setName] = useState(cache.name)    const [age, setAge] = useState(cache.age)    return (        &lt;&gt;            &lt;InputView&gt;                &lt;label&gt;이름&lt;/label&gt;                &lt;MyInput value={name} handleValueChange={(newValue)=&gt; setName(newValue)} /&gt;            &lt;/InputView&gt;            &lt;InputView&gt;                &lt;label&gt;나이&lt;/label&gt;                &lt;MyInput value={age} handleValueChange={(newAge)=&gt; setName(newAge)} /&gt;            &lt;/InputView&gt;            &lt;InputView&gt;                &lt;div className=\"view\"&gt;이름{name}나이{age}&lt;/div&gt;            &lt;/InputView&gt;        &lt;/&gt;    )}stories 작성  컴포넌트명과 stories.js 를 작성하면 컴포넌트의 stories로 인식한다.  Tag 컴포넌트를 불러온다.  기본값의 title은 Example의 폴더 안에 ClickToEdit 컴포넌트를 의미한다.  기본값의 component는 ClickToEdit 컴포넌트를 지칭한다.  stories는 storybook  stories 설명보기import React from \"react\";import {ClickToEdit} from \"./components/ClickToEdit.js\"export default{    title: \"Example/ClickToEdit\",    component: ClickToEdit};const Template = (args) =&gt; &lt;ClickToEdit {...args} /&gt;;export const Primary = Template.bind({});Primary.args = {    primary: true,    label: \"ClickToEdit\"}"
  },
  
  {
    "title": "React 16장 - Autocomplete 기능",
    "url": "/posts/2-React-styled-component-Autocomplete/",
    "categories": "REACT",
    "tags": "react, components, jsx, styled-components, autocomplete",
    "date": "2023-02-22 00:00:00 +0900",
    





    
    "snippet": "ReactAutocomplete  갖고 있는 정보에 일치하는 문자를 입력했을 경우, 아래에 문자와 일치하는 정보를 나타내는 기능 구현컴포넌트 짜기  입력창을 갖고 있는 컴포넌트와 입력을 받았을 때 하위에 자동완성 기능을 나타낼 컴포넌트로 나눈다.  컴포넌트 안에 요소를 작성한다.return (    &lt;InputContainer&gt;       ...",
    "content": "ReactAutocomplete  갖고 있는 정보에 일치하는 문자를 입력했을 경우, 아래에 문자와 일치하는 정보를 나타내는 기능 구현컴포넌트 짜기  입력창을 갖고 있는 컴포넌트와 입력을 받았을 때 하위에 자동완성 기능을 나타낼 컴포넌트로 나눈다.  컴포넌트 안에 요소를 작성한다.return (    &lt;InputContainer&gt;        &lt;input /&gt;    &lt;/InputContainer&gt;    &lt;DropDown /&gt;)Styled-Components  기존의 정보값을 갖고 있을 배열을 임의로 작성해준다.  InputContainer에 div를 만들어 속성을 정한다.          focus-within은 input을 클릭했을 때 발생        상태값에 따라 클래스를 추가하고 빼내어 속성값을 부여한다.const autoValue = [    \"apple\",    \"angle\",    \"adios\",    \"banana\",    \"bare\",    \"bread\",    \"candy\",    \"car\",    \"drop\",    \"down\",    \"function\"]const boxShadow = \"0 4px 6px rgb(32 33 36 / 28%)\";const inactiveBorderRadius = \"1rem 1rem 1rem 1rem\";export const InputContainer = styled.div`    margin-top: 8rem;    background-color: #ffffff;    display: flex;    felx-direction: row;    padding: 1rem;    border: 1px solid rgb(223, 225, 229);    border-radius: ${inactiveBorderRadius};    z-index: 3;    box-shadow: 0;    &amp;:focus-within {        box-shadow: ${boxShadow};    }    &gt; input {        flex: 1 0 0;        background-color: transparent;        border: none;        margin: 0;        padding: 0;        outline: none;        font-size: 16px;    }    &gt; div.delete-button {        cursor: pointer;    }`export const DropDownContainer = styled.ul`    background-color: #ffffff;    display: block;    margin-left: auto;    margin-right: auto;    list-styled-type: none;    margin-block-start: 0;    margin-block-end: 0;    margin-inline-start: 0;    margin-inline-end: 0;    padding-inline-start: 0p;    margin-top: -1px;    padding: 0.5rem 0;    border: 1px solid rgb(223, 225, 229);    border-radius: 0 0 1rem 1rem;    box-shadow: ${boxShadow}    z-index: 3;    &gt; li {        padding: 0 1rem;    }    &gt; li:hover {        background-color: rgb(223,225,229);    }    &amp;.select {        background-color: rgb(223,225,229);    }`기능 구현상태값 작성  초기값은 기존에 작성된 autoValue배열을 갖는다.  hasText는 input창에 값이 입력되었는지를 확인한다.  inputValue는 배열에 input에 입력된 값을 추가하기 위해, input에 작성된 value를 의미한다.  options는 초기에 작성한 autoValue값을 의미한다.  selectedOption는 우리가 선택한 옵션에 따른 index를 가르킨다.  useEffect를 사용하여 input에 입력한 값이 빈 배열이 아닐 때, 기존에 갖고있는 배열과 중복되지 않는다면 값을 추가하기 위해 inputValue의 상태값이 변경될 때마다 새롭게 렌더링한다.          push를 이용하면 기존에 갖고있는 배열의 주소값이 변하지 않아 리액트에서 상태의 변화를 알아차리지 못 하기 때문에 filter,mpa,...을 사용하여 추가한다.      const [hasText, setHasText] = useState(false);const [inputValue, setInputValue] = useState(\"\");const [options, setOptions] = useState(autoValue)const [selectedOption, setSelectedOption] = useState(0)useEffect(()=&gt;{    if(inputValue === \"\"){        setHasText(false);    }    if(inputValue !== \"\"){        setOptions(            autoValue.filter((option)=&gt;option.includes(inputValue))        )    }},[inputValue])컴포넌트에 이벤트 핸들러 부여  값을 입력하거나, 자동완성을 선택하거나, 삭제버튼을 눌렀을 때에 발생할 이벤트를 작성한다.  handleInputChange함수는 이벤트를 발생시킨 요소의 값을 그대로 받아 기존의 배열에 추가하는 역할을 하며, setHasText상태를 true로 만들어 input 값의 유무를 설정한다.  handleDropDownClick함수는 우리가 선택한 자동완성된 값을 input요소의 value로 넣어주는 역할을 한다.  handleDeleteButtonClick함수는 입력한 input창의 value값을 공백으로 만들어, 입력한 값을 삭제해주는 역할을 한다.  handleKeyUp함수는 input을 작성한 상태에서 자동완성된 값을 선택해 주기 위해 실행되며, ArrowDown은 화살표 아래 키를 의미하며, ArrowUp은 화살표 위 키를 눌렀을 때에 index에 값을 추가하거나 빼서 index값을 설정해준다.          작성 후 Enter를 누른다면 handleDropDown함수로 전달인자를 넘겨 기존 배열의 index를 선택한다.      선택 후에는 setSelectedOption을 0으로 만들어, 0번째 index값을 갖게 한다.      const handleInputChange = (event) =&gt; {    setInputValue(event.target.value);    setHasText(true);}const handleDropDownClick = (clickedOption) =&gt; {    setInputValue(clickedOption);}const handleDeleteButtonClick = () =&gt; {    setInputValue(\"\")}const handleKeyUp = (event) =&gt; {    if(event.key === \"ArrowDown\" &amp;&amp; selectedOption &lt; options.length - 1){        setSelectedOption(selectedOption + 1);    }    if(event.key === \"ArrowUp\" &amp;&amp; selectedOption &gt; 0){        setSelectedOption(selectedOption - 1);    }    if(event.key === \"Enter\"){        handleDropDownClick(options[selectedOption])        setSelectedOption(0);    }}코드  적절한 요소에 이벤트 핸들러를 부여한다.  input 요소에 입력된 값을 뜻하는 value는 inputValue인 상태값이다.          input에 값이 입력되면 handleInputChange함수가 실행되는데, 실행되는 함수는 input에 입력된 value값으로 상태값이 변한다.                  함수의 실행 형태로 전달하면 안된다.          키가 입력됐을 때, 키를 판별하여 자동완성의 index를 구하기 위해 selectedOption값이 변경된다.                    delete-button을 누를 때, handleDelelteButtonClick 함수를 실행시키는데, 입력된 값을 초기화한다.      자동완성 기능을 가진 DropDown 컴포넌트는 DropDownContainer 컴포넌트를 갖고 있으며, 기존 값을 갖고 있는 배열 options, 선택한 index의 값에 클래스를 부여할 selectedOption을 인자로 넘겨준다..                  DropDownContainer 컴포넌트는 li요소에 options의 각각의 값과 index를 갖고, option을 handleComboBox가 가진 handleDropDownClick함수로 전달인자를 넘겨주어 선택한 option요소를 input창에 넣어준다.                    import {useState,useEffect} from \"react\"import styled from \"styled-components\"const autoValue = [    \"apple\",    \"angle\",    \"adios\",    \"banana\",    \"bare\",    \"bread\",    \"candy\",    \"car\",    \"drop\",    \"down\",    \"function\"]const boxShadow = \"0 4px 6px rgb(32 33 36 / 28%)\";const inactiveBorderRadius = \"1rem 1rem 1rem 1rem\";export const InputContainer = styled.div`    margin-top: 8rem;    background-color: #ffffff;    display: flex;    felx-direction: row;    padding: 1rem;    border: 1px solid rgb(223, 225, 229);    border-radius: ${inactiveBorderRadius};    z-index: 3;    box-shadow: 0;    &amp;:focus-within {        box-shadow: ${boxShadow};    }    &gt; input {        flex: 1 0 0;        background-color: transparent;        border: none;        margin: 0;        padding: 0;        outline: none;        font-size: 16px;    }    &gt; div.delete-button {        cursor: pointer;    }`export const DropDownContainer = styled.ul`    background-color: #ffffff;    display: block;    margin-left: auto;    margin-right: auto;    list-styled-type: none;    margin-block-start: 0;    margin-block-end: 0;    margin-inline-start: 0;    margin-inline-end: 0;    padding-inline-start: 0p;    margin-top: -1px;    padding: 0.5rem 0;    border: 1px solid rgb(223, 225, 229);    border-radius: 0 0 1rem 1rem;    box-shadow: ${boxShadow}    z-index: 3;    &gt; li {        padding: 0 1rem;    }    &gt; li:hover {        background-color: rgb(223,225,229);    }    &amp;.select {        background-color: rgb(223,225,229);    }`export const Autoncomplete = () =&gt; {    const [hasText, setHasText] = useState(false);    const [inputValue, setInputValue] = useState(\"\");    const [options, setOptions] = useState(autoValue)    const [selectedOption, setSelectedOption] = useState(0)    useEffect(()=&gt;{        if(inputValue === \"\"){            setHasText(false);        }        if(inputValue !== \"\"){            setOptions(                autoValue.filter((option)=&gt;option.includes(inputValue))            )        }    },[inputValue])        const handleInputChange = (event) =&gt; {        setInputValue(event.target.value);        setHasText(true);    }    const handleDropDownClick = (clickedOption) =&gt; {        setInputValue(clickedOption);    }    const handleDeleteButtonClick = () =&gt; {        setInputValue(\"\")    }    const handleKeyUp = (event) =&gt; {        if(event.key === \"ArrowDown\" &amp;&amp; selectedOption &lt; options.length - 1){            setSelectedOption(selectedOption + 1);        }        if(event.key === \"ArrowUp\" &amp;&amp; selectedOption &gt; 0){            setSelectedOption(selectedOption - 1);        }        if(event.key === \"Enter\"){            handleDropDownClick(options[selectedOption])            setSelectedOption(0);        }    }    return (        &lt;div&gt;            &lt;InputContainer&gt;                &lt;input type=\"text\"                value={inputValue}                onChange={(event)=&gt;{                    handleInputChange(event);                }}                onKeyUp={(event)=&gt;{                    handleKeyUp(event)                }}/&gt;                &lt;div className=\"delete-button\" onClick={handleDeleteButtonClick} /&gt;            &lt;/InputContainer&gt;            {options.length &amp;&amp; hasText ? (                &lt;DropDown                 options={options                handleComboBox={handleDropDownClick}                selectedOption={selectedOption}                }            /&gt;) : null}        &lt;/div&gt;    )}export const DropDown = ({options, handleComboBox, selectedOption})=&gt;{    return (        &lt;DropDownContainer&gt;            {options.map(option,index)=&gt;{                return (                    &lt;li                        key={index}                        onClick={()=&gt;handleComboBox(option)}                        className={selectedOption === index ? \"select\" : \"\"}                    &gt;                        {option}                    &lt;/li&gt;                )            }}        &lt;/DropDownContainer&gt;    )}stories 작성  컴포넌트명과 stories.js 를 작성하면 컴포넌트의 stories로 인식한다.  Tag 컴포넌트를 불러온다.  기본값의 title은 Example의 폴더 안에 Tag 컴포넌트를 의미한다.  기본값의 component는 Tag 컴포넌트를 지칭한다.  stories는 storybook  stories 설명보기import React from \"react\";import {Tag} from \"./components/Tag.js\"export default{    title: \"Example/Tag\",    component: Tag};const Template = (args) =&gt; &lt;Tag {...args} /&gt;;export const Primary = Template.bind({});Primary.args = {    primary: true,    label: \"Tag\"}stories 작성  컴포넌트명과 stories.js 를 작성하면 컴포넌트의 stories로 인식한다.  Autocomplete 컴포넌트를 불러온다.  기본값의 title은 Example의 폴더 안에 Autocomplete 컴포넌트를 의미한다.  기본값의 component는 Autocomplete 컴포넌트를 지칭한다.  stories는 storybook  stories 설명보기import React from \"react\";import {Autocomplete} from \"./components/Autocomplete.js\"export default{    title: \"Example/Autocomplete\",    component: Autocomplete};const Template = (args) =&gt; &lt;Autocomplete {...args} /&gt;;export const Primary = Template.bind({});Primary.args = {    primary: true,    label: \"Autocomplete\"}"
  },
  
  {
    "title": "Algorithm 4장 - isSubsetOf",
    "url": "/posts/1-Algorithm-isSubsetOf/",
    "categories": "ALGORITHM",
    "tags": "algorithm",
    "date": "2023-02-22 00:00:00 +0900",
    





    
    "snippet": "isSubsetOf문제  두 개의 배열(base,sample)을 입력받아 sample이 base의 부분집합인지 여부를 리턴한다.let isSubsetOf = function(base,sample){    }입력  base          number 타입을 요소로 갖는 배열      base.lenght는 100 이하        sample     ...",
    "content": "isSubsetOf문제  두 개의 배열(base,sample)을 입력받아 sample이 base의 부분집합인지 여부를 리턴한다.let isSubsetOf = function(base,sample){    }입력  base          number 타입을 요소로 갖는 배열      base.lenght는 100 이하        sample          number 타입을 요소로 갖는 배열      sample.length는 100 이하      출력  boolean 타입을 리턴한다.주의사항  base,sample 내에 중복되는 요소는 없다.입출력 예시let base = [1,2,3,4,5]let sample = [1,3]let output = isSubsetOf(base, sample);console.log(output)// truesample = [6,7]let output = isSubsetOf(base, sample);console.log(output)// falsebase = [10,99,123,7]sample = [11,100,99,123]let output = isSubsetOf(base, sample);console.log(output)// false풀이  각 배열을 오름차순으로 정렬한다.  두 번째 for문에 각 sample[i]와 배열base, 처음엔 0번째 인덱스를 findItemInSortedArr 함수에 전달한다.  전달받은 인자로 item은 sample[i]가 되고 arr는 base, from은 0이 된다.          baseIdx의 초기값은 0이기 때문이다.        findItemInSortedArr의 for문을 돌며 sample의 요소와 base의 요소(i는 전달인자로 넘겨받은 sample의 i번째 인덱스)가 일치하면 sample[i]를 리턴하고, 리턴한 sample[i]는 baseIdx가 된다.          base배열과 sample[i]를 비교하였는데 일치하는 값이 없다면 -1을 리턴한다.        만약 일치한다면 baseIdx는 일치한 sample[i]가 되고, 다시 findItemInSoredArr함수를 돈다.  넘겨받은 전달인자 from이 sample[i]이기 때문에 i는 넘겨받은 sample[i]값으로 시작하게 된다.  arr=base이기에 base의 sample[i]번째 인덱스부터 배열의 끝까지 값 중 일치하는 값이 없다면 -1을 리턴한다.  배열을 전부 돌았을 때, sample의 요소 중 하나라도 base의 요소들과 일치하지 않으면 최종 baseidx는 -1값을 갖게 되며 그대로 false를 리턴하게 된다.  만약 값이 있다면 두 번째 for문의 if문에 걸리지 않으므로 true를 리턴하게 된다.const isSubsetOf = function (base, sample){    base.sort((a,b)=&gt; a - b);    sample.sort((a,b)=&gt; a - b);    const findItemInSortedArr = (item, arr, from) =&gt; {        for(let i = from; i &lt; arr.length; i++){            if(item === arr[i]) return i;        }        return -1;    }    let baseIdx = 0;    for(let i = 0; i &lt; sample.length; i++){        baseIdx = findItemInSoredArr(sample[i], base, baseIdx);        if(baseIdx === -1) return false    }    return true;}"
  },
  
  {
    "title": "React 15장 - Tag 입력",
    "url": "/posts/4-React-styled-components-Tag/",
    "categories": "REACT",
    "tags": "react, components, jsx, styled-components, tag",
    "date": "2023-02-21 00:00:00 +0900",
    





    
    "snippet": "ReactTag  값을 입력 후 Enter 키를 누르면 값이 태그 형태로 들어가는 기능 구현컴포넌트 짜기  컴포넌트를 나눈다.  우리가 작성해야 하는 것은 태그를 감싸고 있는 박스 하나.          그 안에 태그를 달아주는 것과 입력하는 것을 모두 작성했지만 각 컴포넌트로 쪼갤 수 있다.      ul안에 li가 있고, li안에 span요소를 넣...",
    "content": "ReactTag  값을 입력 후 Enter 키를 누르면 값이 태그 형태로 들어가는 기능 구현컴포넌트 짜기  컴포넌트를 나눈다.  우리가 작성해야 하는 것은 태그를 감싸고 있는 박스 하나.          그 안에 태그를 달아주는 것과 입력하는 것을 모두 작성했지만 각 컴포넌트로 쪼갤 수 있다.      ul안에 li가 있고, li안에 span요소를 넣어, 이를 입력하는 배열만큼 각 li와 span안에 값을 뿌려 출력한다.      return (    &lt;TagContainer&gt;        &lt;ul&gt;            &lt;li&gt;                &lt;span&gt;&lt;/span&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;input/&gt;    &lt;/TagContainer&gt;)Styled-Components  TagContainer 컴포넌트를 정렬한다.  ul,li,span,input의 style을 정해준다.  TagesContainer 컴포넌트는 중앙에 위치하며, 그 안에 오는 요소들은 컴포넌트의 시작인 좌측부터 차곡차곡 쌓인다.          만약 컴포넌트의 넓이값을 넘어가면 아래로 떨어뜨려 정렬한다.        li는 tags 클래스를 갖고 있다.          넓이값은 우리가 입력하는 텍스트를 기준으로 자동으로 지정한다.      li안에 있는 텍스트는 상화좌우 자동정렬한다.      li의 list-style을 없앤다.        span은 tags-close-icon 클래스를 갖고 있다.  input은 flex 비율 1값을 갖고 있다.          input요소를 클릭하여 focus되면 외곽선이 투명해진다.      input이 focus-withon이 되었을 때 외곽선이 생기는 것을 색상을 변경해준다.      import {useState} from \"react\"import styled from \"styled-components\"export const TagContainer.div`    margin: 8rem auto;    display: flex;    align-items: flex-start;    flex-wrap: wrap;    min-height: 48px;    width: 480px;    padding: 0 8px;    border: 1px solid rgb(214, 216, 218);    border-radius: 6px;    &gt; ul {        display: flex;        flex-wrap: wrap;        padding: 0;        margin: 8px 0 0;        &gt; .tag {            width: auto;            height: 32px;            display: flex;            align-items: center;            justify-content: center;            color: #fff;            padding: 0 8px;            font-size: 14px;            list-style: none;            border-radius: var(--coz-purple-600);            &gt; .tag-close-icon {                display: block;                width: 16px;                height: 16px;                line-height: 16px;                text-align: center;                font-size: 14px;                margin-left: 8px;                color: var(--coz-purbple-600);                border-radius: 50%;                background: #fff;                cursor: pointer;            }        }    }    &gt; input {        flex: 1;        border: none;        height: 46px;        font-size: 14px;        padding: 4px 0 0 0;        :focus {            outline: transparent;        }    }    &amp;:focus-within {        border: 1px solid var(--coz-purple-600);    }`기능 구현상태값 작성  초기값은 배열 [\"choi\",\"kim\"]을 갖고 있다.  태그를 작성하고 Enter키를 눌렀을 때 함수를 실행한다.          만약 기존값과 내가 이벤트가 발생한 event.target의 입력값인 value와 겹치는 값이 없다면,      입력한 value값이 공백이 아니라면,      기존 배열에 내가 작성한 event.target.value를 넣어준다.        close icon이 부여된 span을 눌렀을 때에 함수를 실행시킨다.          작성된 기존값의 index와 내가 클릭한 값의 index를 일치시켜, 일치하는 값을 제외한 배열을 재구성한다.      const allTags = [\"choi\",\"kim\"]const [tags,setTags] = useState(allTags)const removeTags = (indexToRemove) =&gt; {    setTags(tags.filter((tag)=&gt; tag !== tags[indexToRemove]))}const addTags = (event) =&gt; {    if(        event.key === \"Enter\" &amp;&amp;        !tags.includes(event.target.value) &amp;&amp;        event.target.value !== \"\"    ){        setTags([...tags, event.target.value]);        event.target.value = \"\";    }}컴포넌트에 이벤트 핸들러 부여  li 요소 안 span에 우리가 배열이 가진 값을 부여해 출력한다.  map()의 전달인자index는 배열의 index를 말하며 span className=\"tags-close-icon\"을 눌렀을 때, removeTags를 실행시킨다.          removeTags에 map()으로 넘겨받은 index를 tag.filter에 넘겨주어 내가 클릭한, 이미 작성된 값의 index를 filter로 거른 새로운 배열이 된다.      return (    &lt;&gt;        &lt;TagContaier&gt;            &lt;ul&gt;                {tags.map((tag, index)=&gt; {                    &lt;li key={index} className=\"tags\"&gt;                        &lt;span className=\"tag-title\"&gt;{tags}&lt;/span&gt;                        &lt;span className=\"tags-close-icon\" onClick={()=&gt;removeTags(index)}&gt;                        &lt;/span&gt;                })}            &lt;/ul&gt;            &lt;input className=\"tag-input\" type=\"text\"            onClick={(event)=&gt;{                addTags(event)            }} placeholder=\"Press enter to add tags\"&gt;&lt;&gt;        &lt;/TagContaier&gt;    &lt;/&gt;)코드import {useState} from \"react\"import styled from \"styled-components\"export const TagContainer.div`    margin: 8rem auto;    display: flex;    align-items: flex-start;    flex-wrap: wrap;    min-height: 48px;    width: 480px;    padding: 0 8px;    border: 1px solid rgb(214, 216, 218);    border-radius: 6px;    &gt; ul {        display: flex;        flex-wrap: wrap;        padding: 0;        margin: 8px 0 0;        &gt; .tag {            width: auto;            height: 32px;            display: flex;            align-items: center;            justify-content: center;            color: #fff;            padding: 0 8px;            font-size: 14px;            list-style: none;            border-radius: var(--coz-purple-600);            &gt; .tag-close-icon {                display: block;                width: 16px;                height: 16px;                line-height: 16px;                text-align: center;                font-size: 14px;                margin-left: 8px;                color: var(--coz-purbple-600);                border-radius: 50%;                background: #fff;                cursor: pointer;            }        }    }    &gt; input {        flex: 1;        border: none;        height: 46px;        font-size: 14px;        padding: 4px 0 0 0;        :focus {            outline: transparent;        }    }    &amp;:focus-within {        border: 1px solid var(--coz-purple-600);    }`export const Tag = () =&gt; {    const allTags = [\"choi\",\"kim\"]    const [tags,setTags] = useState(allTags)    const removeTags = (indexToRemove) =&gt; {        setTags(tags.filter((tag)=&gt; tag !== tags[indexToRemove]))    }    const addTags = (event) =&gt; {        if(            event.key === \"Enter\" &amp;&amp;            !tags.includes(event.target.value) &amp;&amp;            event.target.value !== \"\"        ){            setTags([...tags, event.target.value]);            event.target.value = \"\";        }    }    return (        &lt;&gt;            &lt;TagContaier&gt;                &lt;ul&gt;                    {tags.map((tag, index)=&gt; {                        &lt;li key={index} className=\"tags\"&gt;                            &lt;span className=\"tag-title\"&gt;{tags}&lt;/span&gt;                            &lt;span className=\"tags-close-icon\" onClick={()=&gt;removeTags(index)}&gt;                            &lt;/span&gt;                    })}                &lt;/ul&gt;                &lt;input className=\"tag-input\" type=\"text\"                onClick={(event)=&gt;{                    addTags(event)                }} placeholder=\"Press enter to add tags\" /&gt;            &lt;/TagContaier&gt;        &lt;/&gt;    )}stories 작성  컴포넌트명과 stories.js 를 작성하면 컴포넌트의 stories로 인식한다.  Tag 컴포넌트를 불러온다.  기본값의 title은 Example의 폴더 안에 Tag 컴포넌트를 의미한다.  기본값의 component는 Tag 컴포넌트를 지칭한다.  stories는 storybook  stories 설명보기import React from \"react\";import {Tag} from \"./components/Tag.js\"export default{    title: \"Example/Tag\",    component: Tag};const Template = (args) =&gt; &lt;Tag {...args} /&gt;;export const Primary = Template.bind({});Primary.args = {    primary: true,    label: \"Tag\"}"
  },
  
  {
    "title": "React 14장 - Tab 버튼",
    "url": "/posts/3-React-styled-components-Tab/",
    "categories": "REACT",
    "tags": "react, components, jsx, styled-components, tab",
    "date": "2023-02-21 00:00:00 +0900",
    





    
    "snippet": "ReactTab  클릭 시 버튼이 이동하는 Tab버튼 만들기컴포넌트 짜기  컴포넌트를 나눈다.  우리가 작성해야 하는 것은 탭 버튼을 감싸고 있는 박스 하나.  아래 보여줄 텍스트 박스 하나.return (    &lt;TabContainer&gt;        &lt;li&gt;&lt;/li&gt;    &lt;/TabContainer&gt;    ...",
    "content": "ReactTab  클릭 시 버튼이 이동하는 Tab버튼 만들기컴포넌트 짜기  컴포넌트를 나눈다.  우리가 작성해야 하는 것은 탭 버튼을 감싸고 있는 박스 하나.  아래 보여줄 텍스트 박스 하나.return (    &lt;TabContainer&gt;        &lt;li&gt;&lt;/li&gt;    &lt;/TabContainer&gt;    &lt;Desc&gt;        &lt;p&gt;&lt;/p&gt;    &lt;Desc&gt;)Styled-Components  TabContainer 컴포넌트는 버튼의 배경과 버튼 자체를 갖고 있다.  TabContainer 컴포넌트의 li에 class를 지정하여 값을 넣어주고, 탭의 상태값에 따라 클래스를 넣고 빼줄 거기 때문에, 만약 상태값이 어떠한 값을 가지면 임의의 클래스를 넣어주어 속성값이 들어가게 하고, 그렇지 않으면 클래스를 빼서 속성값이 빠지게 한다.  styled.ul을 지정하여 TabContainer 컴포넌트 안을 ul이 감싸고 있게 한다.  기본 클래스인 submenu, 선택했을 시 들어갈 효과인 focused를 작성한다.  탭 메뉴를 선택 시, 보여줄 텍스트에 대한 스타일을 작성한다.const TabContainer = styled.ul`    background-color: #dcdcdc;    color: rgba(73, 73, 73, 0.5);    font-weight: bold;    display: flex;    flex-direction: row;    justify-items: center;    align-items: center;    margin-bottom: 7rem;    &gt; .submenu {        display: flex;        justify-content: center;        align-items: center;        height: 3rem;        width: 32%;        margin-right: 2%;    }    .focused {        background-color: white;    }    &amp; div.desc {        text-align: center;    }`const Desc = styled.div`    text-align: center;`기능 구현상태값 작성  탭 버튼을 클릭했을 때, 선택한 탭 버튼의 index에 따른 상태값이 변화하게 한다.  탭 버튼을 클릭했을 때, 보여줄 정보를 갖고 있게 한다.  탭 버튼을 클릭했을 때, 상태값을 변경시켜 줄 함수를 작성한다.const [currentTab, setCurrentTab] = useState(0)const menu = [    {name:\"Tab1\", content: \"Tab menu One\"},    {name:\"Tab2\", content: \"Tab menu Two\"},    {name:\"Tab3\", content: \"Tab menu Three\"}]const selectMenu = (index) =&gt; {    setCurrentTab(index)}컴포넌트에 이벤트 핸들러 부여  TabContainer안의 li를 클릭했을 때 selectMenu함수를 실행시켜 currentTab의 값이 바뀌게 한다.  바뀐 값에 따라 클래스에 focused가 추가되어 색상이 바뀌게 만든다.  map()에 의해 전달되는 두 번째 인자인 idx는 menu가 가진 index를 뜻한다.  li를 클릭 시, selectMenu함수가 실행되며 각각의 li가 가진 idx 값으로 currentTab의 index 가 바뀌게 된다.  바뀐 currentTab의 content를 Desc 컴포넌트에 출력한다.return (    &lt;&gt;        &lt;TabContainer&gt;            {menu.map((el,idx)=&gt;{                return (&lt;li key={idx}                    onClick={()=&gt;selectMenu(idx)}                    className={`${currentTab === idx ? \"submenu focused\":\"submenu\"}`}                    &gt;                    {el.name}                    &lt;/li&gt;                )            })}        &lt;/TabContainer&gt;        &lt;Desc&gt;{menu[currentTab].content}&lt;/Desc&gt;    &lt;/&gt;)stories 작성  컴포넌트명과 stories.js 를 작성하면 컴포넌트의 stories로 인식한다.  Tab 컴포넌트를 불러온다.  기본값의 title은 Example의 폴더 안에 Tab 컴포넌트를 의미한다.  기본값의 component는 Tab 컴포넌트를 지칭한다.  stories는 storybook  stories 설명보기import React from \"react\";import {Tab} from \"./components/Tab.js\"export default{    title: \"Example/Tab\",    component: Tab};const Template = (args) =&gt; &lt;Tab {...args} /&gt;;export const Primary = Template.bind({});Primary.args = {    primary: true,    label: \"Tab\"}코드import {useState} from \"react\";import styled from \"styled-components\";const TabContainer = styled.ul`    background-color: #dcdcdc;    color: rgba(73, 73, 73, 0.5);    font-weight: bold;    display: flex;    flex-direction: row;    justify-items: center;    align-items: center;    margin-bottom: 7rem;    &gt; .submenu {        display: flex;        justify-content: center;        align-items: center;        height: 3rem;        width: 32%;        margin-right: 2%;    }    .focused {        background-color: white;    }    &amp; div.desc {        text-align: center;    }`const Desc = styled.div`    text-align: center;`export const Tab = () =&gt; {    const [currentTab, setCurrentTab] = useState(0)    const menu = [        {name:\"Tab1\", content: \"Tab menu One\"},        {name:\"Tab2\", content: \"Tab menu Two\"},        {name:\"Tab3\", content: \"Tab menu Three\"}    ]    const selectMenu = (index) =&gt; {        setCurrentTab(index)    }    return (        &lt;&gt;            &lt;TabContainer&gt;                {menu.map((el,idx)=&gt;{                    return (&lt;li key={idx}                        onClick={()=&gt;selectMenu(idx)}                        className={`${currentTab === idx ? \"submenu focused\":\"submenu\"}`}                        &gt;                        {el.name}                        &lt;/li&gt;                    )                })}            &lt;/TabContainer&gt;            &lt;Desc&gt;{menu[currentTab].content}&lt;/Desc&gt;        &lt;/&gt;    )}"
  },
  
  {
    "title": "React 13장 - Toggle 버튼",
    "url": "/posts/2-React-styled-components-Toggle/",
    "categories": "REACT",
    "tags": "react, components, jsx, styled-components, toggle",
    "date": "2023-02-21 00:00:00 +0900",
    





    
    "snippet": "ReactToggle  클릭 시 버튼이 이동하는 Toggle버튼 만들기컴포넌트 짜기  컴포넌트를 나눈다.  우리가 작성해야 하는 것은 토글버튼을 감싸고 있는 박스 하나.  그 안에 이동할 작은 동그라미 버튼 하나.  토글의 상태에 따라 텍스트를 출력할 컴포넌트 하나이다.return (    &lt;ToggleContainer&gt;        &lt...",
    "content": "ReactToggle  클릭 시 버튼이 이동하는 Toggle버튼 만들기컴포넌트 짜기  컴포넌트를 나눈다.  우리가 작성해야 하는 것은 토글버튼을 감싸고 있는 박스 하나.  그 안에 이동할 작은 동그라미 버튼 하나.  토글의 상태에 따라 텍스트를 출력할 컴포넌트 하나이다.return (    &lt;ToggleContainer&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;&lt;/div&gt;    &lt;/ToggleContainer&gt;    &lt;Desc /&gt;)Styled-Components  Toggle 컴포넌트는 버튼의 배경과 버튼 자체를 갖고 있다.  Toggle 컴포넌트의 class를 지정하여 값을 넣어주고, 토글의 상태값에 따라 클래스를 넣고 빼줄 거기 때문에, 만약 상태값이 어떠한 값을 가지면 임의의 클래스를 넣어주어 속성값이 들어가게 하고, 그렇지 않으면 클래스를 빼서 속성값이 빠지게 한다.  &amp;표시는 가상 선택자를 의미하며 현재의 요소를 뜻한다.          hover는 마우스가 올라갔을 때      .class는 어떠한 클래스가 들어갔을 때        position을 상위 컴포넌트인 ToggleContainer에 주어 틀을 기준으로 circle을 조절한다.  Desc는 우리가 입력할 텍스트의 위치를 잡는다.const ToggleContainer = styled.div`    position: relative;    margin-top: 8rem;    left: 47%    cursor: pointer;    &gt; .toggle-container {        width: 50px;        height: 24px;        border-radius: 30px;        background-color: gray;        transition: 1s;        &amp; .toggle--checked {            background: blue;        }    }    &gt; .toggle-circle {        width: 22px;        heigth: 22px;        border-radius: 50%;        background-color: #ffffff;        position: absolute;        transition: 1s;        &amp; .toggle--checked {            left: 27px;        }    }`const Desc = styled.div`    display: flex;    justify-content: center;    margin-top: 1rem;`기능 구현상태값 작성  ToggleContainer을 눌렀을 때의 상태에 따라 toggle--checked클래스를 추가해준다.          toggle--checked가 추가되면 toggle-container의 색상을 바꿔주고,toggle-circle의        ToggleContainer이 클릭됐을 때 상태값이에 따라 전원을 키고 끄듯이 상태값이 달라져야하며, 상태값을 바꿔주기 위한 함수 toggleHandle을 작성해준다.const [isOn,setIsOn] = useState(false)const toggleHandle = () =&gt; {    setIsOn(!isOn)}컴포넌트에 이벤트 핸들러 부여  ToggleContainer을 클릭했을 때 toggleHandle함수를 실행시켜 isOn의 값이 바뀌게 한다.  바뀐 값에 따라 toggle-container와 toggle-circle의 배경색과 버튼이 이동하는 조건을 작성해준다.return (    &lt;&gt;        &lt;ToggleContainer onClick={toggleHandle}&gt;            &lt;div className={`toggle-container ${isOn ? \"toggle--checked\" : \"\"}`} /&gt;            &lt;div className={`toggle-circle ${isOn ? \"toggle--checked\" : \"\"}`} /&gt;        &lt;/ToggleContainer&gt;        &lt;Desc&gt;{isOn ? \"Toggle Switch On\":\"Toggle Switch OFF\"}&lt;/Desc&gt;    &lt;/&gt;)stories 작성  컴포넌트명과 stories.js 를 작성하면 컴포넌트의 stories로 인식한다.  Toggle 컴포넌트를 불러온다.  기본값의 title은 Example의 폴더 안에 Toggle 컴포넌트를 의미한다.  기본값의 component는 Toggle 컴포넌트를 지칭한다.  stories는 storybook  stories 설명보기import React from \"react\";import {Toggle} from \"./components/Toggle.js\"export default{    title: \"Example/Toggle\",    component: Modal};const Template = (args) =&gt; &lt;Modal {...args} /&gt;;export const Primary = Template.bind({});Primary.args = {    primary: true,    label: \"Toggle\"}코드import {useState} from \"react\";import styled from \"styled-components\";export const ToggleContainer = styled.div`    position: relative;    margin-top: 8rem;    left: 47%    cursor: pointer;    &gt; .toggle-container {        width: 50px;        height: 24px;        border-radius: 30px;        background-color: gray;        transition: 1s;        &amp; .toggle--checked {            background: blue;        }    }    &gt; .toggle-circle {        width: 22px;        heigth: 22px;        border-radius: 50%;        background-color: #ffffff;        position: absolute;        transition: 1s;        &amp; .toggle--checked {            left: 27px;        }    }`const Desc = styled.div`    display: flex;    justify-content: center;    margin-top: 1rem;`export const Toggle = () =&gt; {    const [isOn,setIsOn] = useState(false)    const toggleHandle = () =&gt; {        setIsOn(!isOn)    }    return (        &lt;&gt;            &lt;ToggleContainer onClick={toggleHandle}&gt;                &lt;div className={`toggle-container ${isOn ? \"toggle--checked\" : \"\"}`} /&gt;                &lt;div className={`toggle-circle ${isOn ? \"toggle--checked\" : \"\"}`} /&gt;            &lt;/ToggleContainer&gt;            &lt;Desc&gt;{isOn ? \"Toggle Switch On\":\"Toggle Switch OFF\"}&lt;/Desc&gt;        &lt;/&gt;    )}"
  },
  
  {
    "title": "React 12장 - Modal 버튼",
    "url": "/posts/1-React-styled-components-Modal/",
    "categories": "REACT",
    "tags": "react, components, jsx, styled-components, modal",
    "date": "2023-02-21 00:00:00 +0900",
    





    
    "snippet": "ReactModal  클릭 시 알림창을 생성하는 Modal 버튼 만들기컴포넌트 짜기  컴포넌트를 나눈다.  ModalContainer : 전체를 포함하고 있는 컴포넌트 하나  ModalBtn : 모달 기능을 구현할 버튼 하나  ModalBackDrop : 검은색 배경을 구현할 컴포넌트 하나  ModalView : 알림창을 나타낼 컴포넌트 하나retur...",
    "content": "ReactModal  클릭 시 알림창을 생성하는 Modal 버튼 만들기컴포넌트 짜기  컴포넌트를 나눈다.  ModalContainer : 전체를 포함하고 있는 컴포넌트 하나  ModalBtn : 모달 기능을 구현할 버튼 하나  ModalBackDrop : 검은색 배경을 구현할 컴포넌트 하나  ModalView : 알림창을 나타낼 컴포넌트 하나return (    &lt;ModalContainer&gt;        &lt;ModalBtn /&gt;        &lt;ModalBackDrop&gt;            &lt;ModalView /&gt;        &lt;/ModalBackDrop&gt;    &lt;/ModalContainer&gt;)Styled-Components  ModalContainer          Modal 컴포넌트 안에 위치할 하위 컴포넌트들을 display:flex와 justify-content:center,align-items:center을 통해 가운데 정렬을 한다.      position 값은 하위 컴포넌트의 position의 기준이 되기위해 사용한다.        ModalBtn          ModalContainer 안에 위치할 button인 ModalBtn 컴포넌트이다.      display,justify-content,align-items 동일        ModalBackDrop          ModalBtn을 눌렀을 시 BackDrop과 View를 보여줄 컴포넌트이다.      display,justify-content,align-items 동일      상위 컴포넌트인 ModalConatiner의 position을 기준으로 절대적 위치값을 설정한다.      position:absolute를 사용하지 않을 시, ModalBtn과 같은 하위 컴포넌트이기 때문에 ModalBtn에 옆에 위치하게 된다.      따라서, z-index 값을 부여하여 ModalBtn보다 앞에 위치하게 하며 전체 화면을 덮을 수 있도록 ModalContainer의 넓이값과 높이값을 모두 받아온다.        ModalView          ModalBackDrop 안에 위치할 알림창 컴포넌트이다.      ModalBackDrop의 하위 컴포넌트이기 때문에, ModalBackDrop의 justify-content,align-items에 의해 중앙 정렬된다.      const ModalContainer = styled.div`    background-color: lightblue;    display: flex;    justify-content: center;    align-items: center;    height: 20rem;    position: relative;`;const ModalBtn = styled.div`    background-color: blue;    display: flex;    justify-content: center;    align-items: center;    border-radius: 10px;    cursor: grab;`const ModalBackDrop = styled.div`    background-color: rgba(0,0,0,0.5);    display: flex;    justify-content: center;    align-items: center;    width: 100%    height: 100%    position: absolute;    left: 0;    top: 0;    z-index: 10;`const ModalView = styled.div.attrs((props)=&gt;({    role: \"dialog\",}))`    background: white;    display: felx;    flex-direction: column;    justify-content: center;    align-items: center;    width: 200px;    height: 100px;    &gt;. closeBtn {        cursor: pointer;    }`기능 구현상태값 작성  ModalBtn을 눌렀을 때의 상태에 따라 ModalBackDrop과 하위 컴포넌트인 ModalView 컴포넌트가 나타났다,사라졌다를 반복한다.  ModalBtn이 클릭됐을 때 상태값이에 따라 전원을 키고 끄듯이 상태값이 달라져야하며, 상태값을 바꿔주기 위한 함수 onHandle을 작성해준다.const [isModal,setModal] = useState(false)const onHandle = () =&gt; {    setModal(!isModal)}컴포넌트에 이벤트 핸들러 부여  ModalBtn을 클릭했을 때 onHandle함수를 실행시켜 isModal의 값이 바뀌게 한다.  바뀐 값에 따라 ModalBackDrop과 ModalView가 나타나게 하는 조건을 건다.return (    &lt;ModalContainer&gt;        &lt;ModalBtn onClick={onHandle}&gt;{!isModal?\"Open Modal\":\"Opend\"}&lt;/ModalBtn&gt;        {!isModal ? null : &lt;ModalBackDrop onClick={onHandle}&gt;            &lt;ModalView&gt;                &lt;div className=\"closeBtn\"&gt;X&lt;/div&gt;                &lt;div&gt;알림창이 열렸습니다.&lt;/div&gt;            &lt;/ModalView&gt;        &lt;/ModalBackDrop&gt;}    &lt;/ModalContainer&gt;)다듬기  위의 내용만 갖고도 컴포넌트와 기능 구현은 끝났다.  문제점은 ModalBackDrop 컴포넌트를 클릭했을 때 실행되는 onHandle함수를, 하위 컴포넌트인 ModalView 컴포넌트가 그대로 상속받아 ModalView의 어느 영역을 클릭해도 onHandle함수가 실행된다는 것이다.          이를 위해 stopPropagation메서드를 사용한다.      event.preventDefault()와 비슷한 의미를 가진 메서드로, 클릭이벤트가 발생했을 때, 이벤트가 전파되는 것을 막는 기능을 한다.      사용자가 웹페이지 내의 버튼을 클릭했을 때, 버튼을 감싸고 있는 부모 태그들 또한 클릭 이벤트에 반응하게 되는데, 이것을 Bubble Up이라고 한다.      event.stopPropagation()을 사용하여 Bubble Up현상을 막는다.      return (    &lt;ModalContainer&gt;        &lt;ModalBtn onClick={onHandle}&gt;{!isModal?\"Open Modal\":\"Opend\"}&lt;/ModalBtn&gt;        {!isModal ? null : &lt;ModalBackDrop onClick={onHandle}&gt;            &lt;ModalView&gt;                &lt;div className=\"closeBtn\" onClick={(event)=&gt;{                    event.stopPropagation();                }}&gt;X&lt;/div&gt;                &lt;div&gt;알림창이 열렸습니다.&lt;/div&gt;            &lt;/ModalView&gt;        &lt;/ModalBackDrop&gt;}    &lt;/ModalContainer&gt;)stories 작성  컴포넌트명과 stories.js 를 작성하면 컴포넌트의 stories로 인식한다.  Modal 컴포넌트를 불러온다.  기본값의 title은 Example의 폴더 안에 Modal 컴포넌트를 의미한다.  기본값의 component는 Modal 컴포넌트를 지칭한다.  stories는 storybook  stories 설명보기import React from \"react\";import {Modal} from \"./components/Modal.js\"export default{    title: \"Example/Modal\",    component: Modal};const Template = (args) =&gt; &lt;Modal {...args} /&gt;;export const Primary = Template.bind({});Primary.args = {    primary: true,    label: \"Modal\"}코드import {useState} from \"react\";import styled from \"styled-components\"const ModalContainer = styled.div`    background-color: lightblue;    display: flex;    justify-content: center;    align-items: center;    height: 20rem;    position: relative;`;const ModalBtn = styled.div`    background-color: blue;    display: flex;    justify-content: center;    align-items: center;    border-radius: 10px;    cursor: grab;`const ModalBackDrop = styled.div`    background-color: rgba(0,0,0,0.5);    display: flex;    justify-content: center;    align-items: center;    width: 100%    height: 100%    position: absolute;    left: 0;    top: 0;    z-index: 10;`const ModalView = styled.div.attrs((props)=&gt;({    role: \"dialog\",}))`    background: white;    display: felx;    flex-direction: column;    justify-content: center;    align-items: center;    width: 200px;    height: 100px;    &gt;. closeBtn {        cursor: pointer;    }`const [isModal,setModal] = useState(false)const onHandle = () =&gt; {    setModal(!isModal)}return (    &lt;ModalContainer&gt;        &lt;ModalBtn onClick={onHandle}&gt;{!isModal?\"Open Modal\":\"Opend\"}&lt;/ModalBtn&gt;        {!isModal ? null : &lt;ModalBackDrop onClick={onHandle}&gt;            &lt;ModalView&gt;                &lt;div className=\"closeBtn\" onClick={(event)=&gt;{                    event.stopPropagation();                }}&gt;X&lt;/div&gt;                &lt;div&gt;알림창이 열렸습니다.&lt;/div&gt;            &lt;/ModalView&gt;        &lt;/ModalBackDrop&gt;}    &lt;/ModalContainer&gt;)"
  },
  
  {
    "title": "Algorithm 3장 - bubbleSort",
    "url": "/posts/5-Algorithm-bubbleSort/",
    "categories": "ALGORITHM",
    "tags": "algorithm, fibonacci, bubbleSort",
    "date": "2023-02-20 00:00:00 +0900",
    





    
    "snippet": "bubbleSort문제  정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.  버블 정렬(bubble sort)은 여러 정렬 알고리즘(삽입 정렬, 퀵 정렬, 병합 정렬, 기수 정렬 등) 중 가장 기본적인 알고리즘입니다.          첫 번째 요소가 두 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)      두...",
    "content": "bubbleSort문제  정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.  버블 정렬(bubble sort)은 여러 정렬 알고리즘(삽입 정렬, 퀵 정렬, 병합 정렬, 기수 정렬 등) 중 가장 기본적인 알고리즘입니다.          첫 번째 요소가 두 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)      두 번째 요소와 세 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)      1, 2를 마지막까지 반복합니다. (마지막에서 두 번째 요소와 마지막 요소를 비교)      1~3의 과정을 한 번 거치게 되면, 가장 큰 요소가 배열의 마지막으로 밀려납니다.      1~3의 과정을 첫 요소부터 다시 반복합니다.      5를 통해 두 번째로 큰 요소가 배열의 마지막 바로 두 번째로 밀려납니다.      1~3의 과정을 총 n번(배열의 크기) 반복합니다.      let bubbleSort = function (arr) {    }입력  arr          number 타입을 요소로 갖는 배열      arr[i]는 정수      arr[i]의 길이는 1,000 이하      출력  number 타입을 요소로 갖는 배열을 리턴해야 합니다.  배열의 요소는 오름차순으로 정렬되어야 합니다.  arr[i] &lt;= arr[j] (i &lt; j)주의사항  위에서 설명한 알고리즘을 구현해야 합니다.  arr.sort 사용은 금지됩니다.  입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.입출력 예시let output = bubbleSort([2, 1, 3]);console.log(output); // --&gt; [1, 2, 3]Advanced  아래의 힌트를 바탕으로 (최선의 경우) 수행 시간을 단축할 수 있도록 코드를 수정해보세요.  위에서 설명된 알고리즘 1~3의 과정 중 어떤 요소도 위치가 바뀌지 않은 경우, 배열이 정렬된 상태라는 것을 알 수 있습니다.풀이  두 변수를 바꾸는 법 중 하나는 임시 변수를 선언하여 그 값에 바꾸고 싶은 변수 중 하나인 a를 할당하고, 나머지 하나의 변수값으로 값을 재구성한다.          값이 바뀌면 a라는 변수의 기존값을 잃기때문에, b라는 자리에는 임시변수를 부여하여 a를 할당해준다.        또는 구조분해할당을 사용할 수 있다.  swap를 선언하여 swap가 실행된 횟수를 기록한다.          swap이 0일 경우, 배열은 정렬되지 않은 상태이다.        그 다음 반복문에서 매 반복마다 i번째로 큰 수가 마지막에서 i번째 위치하게 한다.  만약 j가 j+1번째보다 크다면, swap함수를 인자를 전달하여 위치를 바꿔준다.  for문이 끝났을 때는 배열이 정렬된 상태이기 때문에 이를 출력한다.const swap = function (idx1, idx2, arr) {    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];}let bubbleSort = function (arr) {  let N = arr.length;  for (let i = 0; i &lt; N; i++) {    let swaps = 0;    for (let j = 0; j &lt; N - 1 - i; j++) {      if (arr[j] &gt; arr[j + 1]) {        swaps++;        swap(j, j + 1, arr);      }    }    if (swaps === 0) {      break;    }  }  return arr;};"
  },
  
  {
    "title": "React 11장 - useRef",
    "url": "/posts/4-React-useRef/",
    "categories": "REACT",
    "tags": "react, components, useref",
    "date": "2023-02-20 00:00:00 +0900",
    





    
    "snippet": "ReactuseRef  useState,useEffet 등을 통해 거의 대부분의 프론트엔드 요구사항을 구현할 수 있었지만, 모든 기능을 구현할 순 없다.  DOM 엘리먼트의 주솟값을 활용해야 하는 경우 useRef로 DOM노드, 엘리먼트, React 컴포넌트의 주솟값을 참조하여야 한다.          focus      text selection  ...",
    "content": "ReactuseRef  useState,useEffet 등을 통해 거의 대부분의 프론트엔드 요구사항을 구현할 수 있었지만, 모든 기능을 구현할 순 없다.  DOM 엘리먼트의 주솟값을 활용해야 하는 경우 useRef로 DOM노드, 엘리먼트, React 컴포넌트의 주솟값을 참조하여야 한다.          focus      text selection      media playback      애니메이션 적용      d3d.js , greensock 등 DOM 기반 라이브러리 활용        제시된 상황을 제외한 대부분의 경우 기본 React문법을 벗어나 useRef를 남용하는 것은 부적절하고, React의 특징이자 장점인 선언형 프로그래밍 원칙과 배치되기 때문에 조심해서 사용해야 한다.예시  주솟값 자체는 컴포넌트가 re-render 되더라도 바뀌지 않는다.  이러한 특성을 활용하여 useRef를 사용한다.  inputEl에 참조자료형의 주솟값을 담고, 주소값을 담은 변수를 props로 담으면 input DOM 엘리먼트의 주소가 담긴다.  다른 컴포넌트에서 input DOM 엘리먼트를 활용할 수 있다.function TextInputWithFocusButton(){    const inputEl = useRef(null);    const onButtonClick = () =&gt; {        inputEl.current.focus()    }    return (        &lt;&gt;            &lt;input ref={inputEL} type=\"text\" /&gt;            &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;        &lt;/&gt;    )}예시 2  sandbox 예제보기  useRef를 통해 각 요소(input)의 주솟값을 담고있다.  input요소에 타이핑을 할 때마다 handleInput함수가 실행되는데 모든 값을 입력 후 Enter를 누르면, handleInput함수의 첫 번쨰 if문의 조건과 맞아진다.  handleInput은 event를 인자로 받는데, event는 handleInput을 발생시킨 input요소를 가르킨다.  input에 입력된 key가 Enter일 경우에는 아래의 if조건문을 실행한다.          세 번째까지 모두 작성 후 Enter를 눌렀다면, 현재의 입력창은 세 번째 input요소이다.      세 번째 if문의 조건 event.target === thirdRef.current 이라면 (이벤트를 발생시킨 요소가 thirdRef(세 번째 input)) 첫 번째 요소의 주솟값을 담고있는 firstRef를 focus해주고, thirdRef의 값을 빈 값으로 만들어준다.      이러한 과정이 반복되어 Enter를 반복했을 때에 모든 input 안에는 공백만 남는다.      import React, {useRef} from \"react\"const Focus = () =&gt; {    const firstRef = useRef(null);    const secondRef = useRef(null);    const thirdRef = useRef(null);    const handleInput = (event) =&gt; {        if(event.key === \"Enter\"){            if(event.target === firstRef.current){                secondRef.current.focus();                event.target.value = \"\";            }else if(event.target === secondRef.current){                thirdRef.current.focus();                event.target.value = \"\";            }else if(event.target === thirdRef.current){                firstRef.current.focus();                event.target.value = \"\";            }else{                return            }        }    }}return (    &lt;div&gt;        &lt;h1&gt;타자연습&lt;/h1&gt;        &lt;h3&gt;각 단어를 바르게 입력하고 엔터를 누르세요.&lt;/h3&gt;        &lt;div&gt;            &lt;label&gt;Hello&lt;/label&gt;            &lt;input ref={firstRef} onKeyUp={handleInput} /&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;label&gt;there&lt;/label&gt;            &lt;input ref={secondRef} onKeyUp={handleInput} /&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;label&gt;here&lt;/label&gt;            &lt;input ref={thirdRef} onKeyUp={handleInput} /&gt;        &lt;/div&gt;    &lt;/div&gt;)export default Focus;예시 3  sandbox 예제보기  비디오의 주솟값을 videoRef에 담는다.  각각 Play,Pause button이 존재하는데, 버튼을 클릭 시 playVideo,pauseVideo함수가 실행되는데, videoRef를 play(),pasue()를 한다.  button에 의해 video가 재생되거나 멈춘다.import {useRef} from \"react\"export default function App(){    const videoRef = useRef(null);    const playVideo = () =&gt; {        videoRef.current.play();    }    const pauseVideo = () =&gt; {        videoRef.current.pause();        videoRef.current.remove();    }}return (    &lt;div&gt;        &lt;div&gt;            &lt;button onClick={playVideo}&gt;Play&lt;/button&gt;            &lt;button onClick={pauseVideo}&gt;Pause&lt;/button&gt;        &lt;/div&gt;        &lt;video ref={videoRef} width=\"320\" height=\"240\" constrols&gt;            &lt;source type=\"video/mp4\" src=\"https://예제.mp4\" /&gt;        &lt;/video&gt;    &lt;/div&gt;)"
  },
  
  {
    "title": "React 10장 - Storybook",
    "url": "/posts/3-React-Storybook/",
    "categories": "REACT",
    "tags": "react, components, storybook",
    "date": "2023-02-20 00:00:00 +0900",
    





    
    "snippet": "Storybook  CDD(Component Driven Development)를 하기 위한 도구로, 각각의 컴포넌트들을 따로 볼 수 있게 구성해 주어 한 번에 하나의 컴포넌트에서 작업할 수 있다.  복잡한 개발 스택을 시작하거나, 특정 데이터를 데이터베이스로 강제 이동하거나, 애플리케이션을 탐색할 필요 없이 전체 UI를 한눈에 보고 개발할 수 있다....",
    "content": "Storybook  CDD(Component Driven Development)를 하기 위한 도구로, 각각의 컴포넌트들을 따로 볼 수 있게 구성해 주어 한 번에 하나의 컴포넌트에서 작업할 수 있다.  복잡한 개발 스택을 시작하거나, 특정 데이터를 데이터베이스로 강제 이동하거나, 애플리케이션을 탐색할 필요 없이 전체 UI를 한눈에 보고 개발할 수 있다.  재사용성 확대를 위해 컴포넌트를 문서화하고, 자동으로 컴포넌트를 시각화하여 시뮬레이션할 수 있는 다양한 테스트 상태를 확인할 수 있다.  이를 통해 버그를 사전에 방지하고 테스트 및 개발 속도를 향상시키는 장점이 있으며 의존성을 걱정하지 않고 빌드할 수 있다.Storybook 주요 기능  UI 컴포넌트들을 카탈로그화하기  컴포넌트 변화를 Stories로 저장하기  핫 모듈 재 로딩과 같은 개발 툴 경험 제공  리액트를 포함한 다양한 뷰 레이어 지원사용방법  본인이 만든 프로젝트의 폴더 안에서 Storybook을 설치한다.          npx storybook init      꼭 리액트가 아니더라도 프론트엔드 라이브러리에 맞는 사용 환경을 알아서 만들어주기 때문에 다양한 프론트엔드 라이브러리에서 사용할 수 있다.        설치가 완료되면 storybook 폴더가 생성된다.          npm run storybook 명령어를 통해 StoryBook을 실행시킬 수 있다.      리액트가 localhost:3000으로 접근하듯이, localhost:6006으로 접근하여 실행시킨다.        stories 폴더 안에 있는 Storybook에서 만들어놓은 예시 스토리를 확인할 수 있다.          애플리케이션을 실행하고 이벤트를 통해 상태를 변경하는 과정을 거치지 않아도 상태 변화에 따른 컴포넌트 변화를 확인할 수 있다.      예시  Title 컴포넌트          컴포넌트는 title과 textColor를 인자로 받는다.      인자로 받은 title은 우리가 만들 요소의 이름으로 쓰이고 입력받은 textColor는 색상의 값으로 사용된다.      import React from \"react\"const Title = ({title, textColor}) =&gt; {    return (                &lt;&gt;            &lt;h1 title={{color: textColor}}&gt;{title}&lt;/h1&gt;        &lt;/&gt;            )}export default Title;  Title.stories 컴포넌트          ./storybook 안에 있는 Storybook 설정 파일에 의해 컴포넌트 파일과 똑같은 이름에 .stories를 붙여 파일을 만들면 알아서 스토리로 인식한다.      export default                  Title 컴포넌트를 불러오고 기본값으로 등록을 해줄 건데, 무엇을 등록을 할 거냐          title : 컴포넌트의 이름을 하나의 카테고리에 넣어 카테고리화 시켜 줄 것이다.          component : 우리가 불러올 컴포넌트의 이름          argTypes : title과 textColor로 받는 타입은 text타입을 받아 이것을 각각 만들 요소에 title과 textColor로 사용하겠다.                    Template 컴포넌트를 하나 만들어, Template 컴포넌트에서 받은 인자를 Title 컴포넌트의 props로 넘겨주겠다.                  하나의 문법으로 생각하면 된다.                    RedTitle 이라는 컴포넌트를 생성한다.                  이 컴포넌트에는 title과 color에 대한 정보를 담고 있는데, 스토리북에 생성된 RedTitle을 클릭하면, RedTitle에 담겨있는 title과 color 정보가 Template 컴포넌트로 전달된다.          전달된 값을 받아 Template 컴포넌트에서 Title의 props로 넘겨주어 Title 컴포넌트 파일에 작성된 요소를 생성한다.                    import Title from \"./Title.js\"export default {    title: \"Practice/Title\",    component: Title,    argTypes: {        title : {control: \"text\"},        textColor: {control: \"text\"}    }}const Template = (args) =&gt; &lt;Title {...args} /&gt;export const RedTitle = Template.bind({})RedTitle.args={   title: \"Red Title\",   textColor: \"red\"}export const BlueTitle = Template.bind({})BlueTitle.args={   title: \"Blue Title\",   textColor: \"blue\"}  전달인자로 직접 받는 스토리          위에서 작성한 코드에 템플릿을 활용하지 않고 바로 전달인자로 받고 있는 예제이다.      아래의 코드를 스토리 바로 밑에 작성한다.      ***export const StorybookTitle = (args) =&gt; {    return &lt;Title {...args} /&gt;}예시 2  위의 코드는 정해진 컴포넌트 RedTitle, BlueTitle과 같은 컴포넌트에 미리 값을 담아, 그 값을 Title 컴포넌트에게 전달해주는 방식이었다.  2번째 예시는 우리가 작성한 값을 입력받아 색상과 타이틀을 정하겠다는 방식으로 구현한 것이다.  Button 컴포넌트import React from \"react\"import styled from \"styled-components\"const StyledButton = styled.button`    background: ${(props) =&gt; props.color || \"white\"}    width: ${(props) =&gt; (props.size === \"big\" ? \"200px\":\"100px\")}    height: ${(props) =&gt; (props.size === \"big\" ? \"80px\":\"40px\")}`const Button = ({color, size, text}) =&gt; (    &lt;StyledButton color={color} size={size}&gt;{text}&lt;/StyledButton&gt;)export default Button  Button.stories.jsimport Button from \"./Button.js\"export default {    title: \"Practice/Button\",    component: Button,    argTypes: {        color: {control: \"color\"},        size: {constrol: {type:\"radio\", options: [\"big\", \"small\"]}},        text: {control: \"text\"}    }}export const StorybookButton = (args) =&gt; (    &lt;Button {...args} /&gt;)"
  },
  
  {
    "title": "React 9장 - CDD(Component Driven Development)",
    "url": "/posts/2-React-CDD/",
    "categories": "REACT",
    "tags": "react, components, cdd, bem, sass",
    "date": "2023-02-20 00:00:00 +0900",
    





    
    "snippet": "CDDComponent Driven Development  컴포넌트 주도 개발의 약자로, 사용자 인터페이스 (UI) 구축에 도달하는 개발 방법론이다.  기본적인 컴포넌트 단위부터 시작하여 UI 뷰(view)를 구성하기 위해 점진적으로 결합(조립)해가는 상향적(bottom-up) 성향을 띈다.  레고처럼 조립해 나갈 수 있는 부품 단위의 컴포넌트를 만들...",
    "content": "CDDComponent Driven Development  컴포넌트 주도 개발의 약자로, 사용자 인터페이스 (UI) 구축에 도달하는 개발 방법론이다.  기본적인 컴포넌트 단위부터 시작하여 UI 뷰(view)를 구성하기 위해 점진적으로 결합(조립)해가는 상향적(bottom-up) 성향을 띈다.  레고처럼 조립해 나갈 수 있는 부품 단위의 컴포넌트를 만들어 나가는 개발이다.CSS in Js  프로젝트의 규모나 복잡도가 점점 커지고 함께 작업해야 하는 팀원 수가 많아지는 것에 비해 CSS를 작성하는 일관된 패턴이 없었다.  CSS 작업을 효율적으로 하기 위해 구조화된 CSS의 필요성이 높아졌다.  이에 CSS전처리기(CSS Preprocessor)라는 개념이 등장했는데, 전처리기는 CSS가 구조적으로 작성될 수 있게 도와주는 도구이다.  CSS는 반복적으로 해야하는 작업이 많고 문서의 양이 많아져 유지관리에도 많은 영향을 끼치게 된다. 이러한 CSS의 문제들을 전처리기의 프로그래밍 개념(변수, 함수, 상속 등) 을 활용하여 해결한다.  전처리기는 자체적으로 웹 서버가 인지하지 못하기 떄문에 각 CSS 전처리기에 맞는 Compiler를 사용해야 하고, 컴파일 하게 되면 우리가 사용하는 CSS 문서로 변환이 된다.SASS  가장 유명한 CSS 전처리기로, Syntactically Awesome Style Sheets의 약자이며 CSS를 확장해 주는 대표적인 스크립팅 언어이다.  자바스크립트처럼 특정 속성의 값을 변수로 선언하여 필요한 곳에 선언된 변수를 적용할 수 있고, 반복되는 코드를 한 번의 선언으로 여러 곳에 재사용할 수 있는 기능을 가졌다.  하지만 많은 문제점을 발견하여, 결국 전처리기가 내부에서 어떤 작업을 하는지 알지 못한 채, 스타일이 겹치는 문제를 해결하기 위해 단순히 계층 구조를 만들어 내는 것에 의지하게 되었다.  CSS 전처리기의 문제를 보완하기 위해 나온 방법론으로 BEM, OOCSS, SMACSS가 있다.          공통 지향점      코드의 재사용성 강화      코드의 간결화(유지 보수 용이)      코드의 확장성      코드의 예측성(클래스 명으로 의미 예측)        문제점          전처리 과정이 필요하다.      디버깅의 어려움이 있다.      컴파일한 CSS파일이 거대해진다.      BEM과 Styled-ComponentBEM  Block, Element, Modifier로 구분하여 클래스명을 작성하는 방식으로, Block, Element, Modifier은 각각 __와 --로 구분한다.          Block : 전체를 감싸고 있는 블럭 요소      Element : 블럭이 포함하고 있는 한 조각      Modifier : 블럭 또는 요소의 속성(블럭이나 엘리먼트의 외관이나 상태를 변화가능하게 하는 부분)        .header__navigation--naviText{color: red;}// header(Block), navigation(Element), naviText(Modifier)                      클래스명은 BEM 방식의 이름을 여러 번 반복하여 재사용할 수 있게 하며 HTML/CSS/SASS 파일에서도 일관된 코딩 구조를 만들어 준다.  문제점          클래스명 선택자가 장황해진다.      긴 클래스명 때문에 마크업이 불필요하게 커진다.      재사용을 위해 모든 UI 컴포넌트를 명시적으로 확장해야만 한다.      캡슐화가 없기 때문에 개발자들이 유일한 클래스명을 선택하는 것에 의존한다.                  캡슐화(encapsulation) : 객체의 속성과 행위를 하나로 묶고 실제 구현 내용의 일부를 외부에 감추어 은닉하는 개념                    Styled-Component  기능적 혹은 상태를 가진 컴포넌트들로부터 UI를 완전히 분리해서 사용할 수 있는 아주 단순한 패턴을 갖고 있다.  컴포넌트 기반으로 CSS를 작성할 수 있게 도와주는 라이브러리이다.  CSS를 컴포넌트 안으로 캡슐화가 가능하며 네이밍이나 최적화를 신경 쓸 필요가 없다.  빠른 페이지 로드에 불리하다.정리                   특징      장점      단점                  CSS      기본적인 스타일링 방법             일관된 패턴을 갖기 어렵고 !important가 남용된다.              SASS(preprocessor)      프로그래밍 방법론을 도입하여, 컴파일된 CSS를 만들어내는 전처리기      변수/함수/상속 개념을 활용하여 재사용 가능, CSS구조화      전처리 과정이 필요하며, 디버깅의 어렴움이 있고 컴파일한 CSS 파일이 거대해진다.              BEM      CSS클래스명 작성에 일관된 패턴을 강제하는 방법론      네이밍으로 문제 해결, 전처리 과정 불필요      선택자의 이름이 장황하고 클래스의 목록이 많아진다.              Styled-Component      컴포넌트 기반으로 CSS를 작성할 수 있게 도와주는 라이브러리      CSS를 컴포넌트 안으로 캡슐화, 네이밍이나 최적화를 신경 쓸 필요가 없다.      빠른 페이지 로드에 불리하다.      "
  },
  
  {
    "title": "React 8장 - Styled-Component",
    "url": "/posts/1-React-styled-component/",
    "categories": "REACT",
    "tags": "react, components, styled-components, ui",
    "date": "2023-02-18 00:00:00 +0900",
    





    
    "snippet": "Styled Component  기존 DOM을 만드는 방식인, css나 scss 파일을 따로 생성하고 이를 불러와 사용하는 것이 아닌 컴포넌트 내부에 style을 작성하는 것을 말한다.  style을 따로 불러와 사용하지 않기 때문에 css의 속성이 전역으로 중첩되어 적용되는 것을 방지한다는 장점이 있다.npm install Styled-Compone...",
    "content": "Styled Component  기존 DOM을 만드는 방식인, css나 scss 파일을 따로 생성하고 이를 불러와 사용하는 것이 아닌 컴포넌트 내부에 style을 작성하는 것을 말한다.  style을 따로 불러와 사용하지 않기 때문에 css의 속성이 전역으로 중첩되어 적용되는 것을 방지한다는 장점이 있다.npm install Styled-Component  라이브러리를 설치 후 package.json파일에 다음의 코드를 추가하여 여러 버전의 Styled-Component가 설치되어 발생하는 문제를 줄여주는 것을 권장하고 있다.    {  \"resolutions\":{      \"styled-component\": \"^5\"  }}        사용할 파일에 Styled-Component를 불러와준다.Styled-Component 만들기  `const 컴포넌트명 = Styled-Component 만든다.  만들고자 하는 컴포넌트의 render 함수 밖에서 작성한다.스타일에 props 적용하기  Styled-Component는 변수에 의해 스타일을 바꿀 수 있다는 장점이 있다.  예를 들어, email 이라는 state 값에 따라 ExampleWrap 컴포넌트에 prop 으로 내려주는 active 값이 true 혹은 false 로 바뀐다.  Styled-Component 는 내부적으로 props를 받을 수 있고, props 에 따라 스타일을 변경할 수 있다.예시import React,{ useState } from \"react\";import styled from \"styled-component\";const ExampleWrap = () =&gt; {    const [email, setEmail] = useState(\"\");    return(        &lt;ExampleWrap active={email.length}&gt;            &lt;Button&gt;Hello&lt;/Button&gt;            &lt;NewButton color=\"blue\"&gt;new Button&lt;/NewButton&gt;        &lt;/ExampleWrap&gt;    );}const ExampleWrap = styled.div`  background: ${({ active }) =&gt; {    if (active) {      return \"white\";    }    return \"#eee\";  }};  color: black;`;const Button = styled.button`    width: 200px;    padding: 30px;`;// Button 컴포넌트 상속const NewButton = styled.button`    color: ${props =&gt; porps.color || \"red\"}`;// NewButton 컴포넌트에 color가 있으면// 입력된 color 값을 사용,// 없으면 'red' 사용export default Example;컴포넌트 재활용하여 새로운 컴포넌트 만들기  sandbox 예제보기import React from \"react\"import styled from \"styled-components\"const BlueButton = styled.button`    background-color: blue;    color: white;`;const BigBlueButton = styled(BlueButton)`    padding: 10px;    margin-top: 10px;`const BigRedButton = styled(BigBlueButton)`    background-color: red;`export default function App(){    return (        &lt;&gt;            &lt;BlueButton&gt;Blue Button&lt;/BlueButton&gt;            &lt;br /&gt;            &lt;BlueBlueButton&gt;Big Blue Button&lt;/BlueBlueButton&gt;            &lt;br /&gt;            &lt;BlueRedButton&gt;Big Red Button&lt;/BlueRedButton&gt;            &lt;br /&gt;        &lt;/&gt;    )}Props 활용하기  React의 컴포넌트처럼 props를 내려줄 수 있다.  템플릿 리터럴 문법을 사용하여 props를 인자로 받는 함수를 만들어 사용하면 된다.  sandbox 예제보기import React from \"react\"import styled from \"styled-components\"import Globalstyle from \"./Globalstyle.js\"const Button1 = styled.button`    background: ${(props) =&gt; (props.skyblue?skyblue:white)}`export default function App (){    return(        &lt;&gt;            &lt;Globalstyle /&gt;            &lt;Button1&gt;Button1&lt;/Button1&gt;            &lt;Button1 skyblue&gt;Button1&lt;/Button1&gt;        &lt;/&gt;    )}Props 값으로 렌더링하기  props의 값을 통째로 활용해서 컴포넌트 렌더링에 활용할 수 있다.  sandbox 예제보기import React from \"react\"import styled from \"styled-components\"import GlobalStyle from \"./GlobalStyle.js\"const Button1 = styled.button`    background:${(props)=&gt;(props.color ? props.color : \"white\")}`const Button2 = styled.button`    background:${(props)=&gt;props.color||\"white\"};`export default function App(){    return (        &lt;&gt;            &lt;GlobalStyle /&gt;            &lt;Button1&gt;Button1&lt;/Button1&gt;            &lt;Button1 color=\"orange\"&gt;Button1&lt;/Button1&gt;            &lt;Button1 color=\"tomato\"&gt;Button1&lt;/Button1&gt;            &lt;Button2&gt;Button2&lt;/Button2&gt;            &lt;Button2 color=\"pink\"&gt;Button2&lt;/Button2&gt;            &lt;Button2 color=\"turquoise\"&gt;Button2&lt;/Button2&gt;        &lt;/&gt;    )}전역 스타일 설정하기  전역에 스타일을 설정하고 싶다면 createGlobalStyle을 불러온다.  CSS 파일을 작성하듯 설정해주고 싶은 스타일을 작성한다.  작성한 &lt;GlobalStyle&gt;을 최상위 컴포넌트에 사용하면 전역에 스타일이 적용된다.응용 hover 이벤트  sandbox 예제보기import React from \"react\"import styled,{createGlobalStyle} from \"styled-components\"const Btn = styled.button`    background : blue;    border-radius: 1rem;    transition: 0.5s;    &amp;: hover {        background: darkblue;        color: white;        transition: 0.5s;    }`export default function App(){    return (        &lt;div&gt;            &lt;GlobalStyle /&gt;            &lt;Btn&gt;Btn&lt;/Btn&gt;            &lt;Btn id=\"practice\"&gt;Btn+id&lt;/Btn&gt;        &lt;/div&gt;    )}Mixin css props  css props 는 자주 쓰이는 css 속성을 담는 변수이다.  css 변수명 = css 로 작성한다.const flexCenter = css`    display: flex;    justify-content: center;    align-items: center;    `;const FlexBox = div`    ${flexCenter}    `;다른 파일에서 컴포넌트 import 하기  해당 파일에서 정의한 css를 export 하여 다른 파일에서 import 할 수 있다.// Login.jsxexport const LoginContainer = styled.div`    background: red;`;// Other.jsximport {LoginContainer} from \"Login.jsx\";const Other = () =&gt; {    return &lt;LoginContainer&gt;&lt;/LoginContainer&gt;;};반응형 디자인  Styled-Component 를 이용한 반응형 디자인 참조import React from \"react\"import Styled-Componentm \"Styled-Component\"const sizes = {    desktop: 1024,    tablet: 768};// sizes 객체에 따라 자동으로 media 쿼리 함수를 만들어준다.const media = Object.keys(sizes).reduce((acc,cur)=&gt;(    acc[label] = (...args) =&gt; css`@meadia (max-width: ${sizes[label] / 16}em) {        ${css(...args)}    }`;    return acc;), {});const Box = Styled-Component// props로 넣어준 값을 직접 전달해줄 수 있다.    background: ${props =&gt; props.color || \"blue\"};    padding: 1rem;    display: flex;    width: 1024px;    margin: 0 auto;    ${media.desktop`width: 768px;`}    ${media.tablet`width: 768px;`};    `;    "
  },
  
  {
    "title": "Algorithm 2장 - fibonacci",
    "url": "/posts/1-Algoritm-fibonacci/",
    "categories": "ALGORITHM",
    "tags": "algorithm, fibonacci",
    "date": "2023-02-15 00:00:00 +0900",
    





    
    "snippet": "fibonacci문제  아래와 같이 정의된 피보나치 수열 중 n번째 항의 수를 리턴해야 합니다.          0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1입니다. 그 다음 2번째 피보나치 수부터는 바로 직전의 두 피보나치 수의 합으로 정의합니다.      0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …      fun...",
    "content": "fibonacci문제  아래와 같이 정의된 피보나치 수열 중 n번째 항의 수를 리턴해야 합니다.          0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1입니다. 그 다음 2번째 피보나치 수부터는 바로 직전의 두 피보나치 수의 합으로 정의합니다.      0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …      function fibonacci(n) {    }입력  n          number 타입의 n(n은 0이상의 정수)      출력  number 타입을 리턴한다.주의사항  재귀함수를 이용해 구현해야 합니다.  반복문(for, while) 사용은 금지됩니다.  함수 fibonacci가 반드시 재귀함수일 필요는 없습니다.입출력 예시let output = fibonacci(0);console.log(output); // --&gt; 0output = fibonacci(1);console.log(output); // --&gt; 1output = fibonacci(5);console.log(output); // --&gt; 5output = fibonacci(9);console.log(output); // --&gt; 34풀이  피보나치의 0번째 피보나치는 0이고, 1번째 피보나치는 1이다. 그 다음 2번째 피보나치 수부터 합으로 정의하기 때문에 값을 미리 저장한다.  함수를 하나 더 만들고, 인자로 n을 넘겨준다.          만약 n번째 피보나치 수가 저장되지 않았다면, n번째 숫자를 구하기 위해 재귀함수를 돌려 n-1번 째와 n-2번 째 숫자를 더해 n번째 숫자를 정의한다.        새롭게 만든 함수에 n을 전달한다.function fibonacci(n) {  let result = [0,1]  let fibonaccici= (n) =&gt;{    if(result[n] === undefined){      result[n] = fibonaccici(n-1) + fibonaccici(n-2)    }    return result[n]  }  return fibonaccici(n)}"
  },
  
  {
    "title": "Algorithm 1장 - largestProductOfThree",
    "url": "/posts/1-Algoritm-largestProductOfThree/",
    "categories": "ALGORITHM",
    "tags": "algorithm",
    "date": "2023-02-14 00:00:00 +0900",
    





    
    "snippet": "largestProductOfThree문제  정수를 요소로 갖는 배열을 입력받아 3개의 요소를 곱해 나올 수 있는 최대값을 리턴해야 합니다.const largestProductOfThree = function (arr) {    }입력  arr          number 타입을 요소로 갖는 배열      출력  number 타입을 리턴한다.주의사항 ...",
    "content": "largestProductOfThree문제  정수를 요소로 갖는 배열을 입력받아 3개의 요소를 곱해 나올 수 있는 최대값을 리턴해야 합니다.const largestProductOfThree = function (arr) {    }입력  arr          number 타입을 요소로 갖는 배열      출력  number 타입을 리턴한다.주의사항  입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.  배열의 요소는 음수와 0을 포함하는 정수입니다.  배열의 길이는 3 이상입니다.입출력 예시let output = largestProductOfThree([2, 1, 3, 7]);console.log(output); // --&gt; 42 (= 2 * 3 * 7)output = largestProductOfThree([-1, 2, -5, 7]);console.log(output); // --&gt; 35 (= -1 * -5 * 7)풀이  배열을 오름차순으로 정렬한다.          sort는 문자열의 크기를 비교하기 때문에 number타입을 정렬할 시 인자를 전달해야 한다.        max는 배열의 끝에서부터 3개의 숫자들을 곱한다.  min는 배열의 앞에서부터 3개의 숫자들을 곱한다.          배열의 요소들에 음수 * 음수가 있는 경우를 생각한다.        계산된 숫자들 중에서 가장 큰 값을 리턴한다.const largestProductOfThree = function (arr) {  arr.sort((a,b) =&gt; a-b)  let max = arr[arr.length-1] * arr[arr.length-2] * arr[arr.length-3]  let min = arr[0] * arr[1] * arr[arr.length-1]  return Math.max(max,min)};"
  },
  
  {
    "title": "React 7장 - Effect Hook",
    "url": "/posts/1-React-Effect-Hook/",
    "categories": "REACT",
    "tags": "react, usestate, useeffect, jsx, props",
    "date": "2023-02-03 00:00:00 +0900",
    





    
    "snippet": "ReactEffect Hook  useEffect는 컴포넌트 내에서 Side Effect를 실행할 수 있게 하는 Hook이다.  useEffect는 두 가지 인자를 전달받는데, 첫 번째 인자는 함수이며 두 번째 인자는 언제 배열을 받아 언제 실행될지를 결정한다.  두 번째 인자로 전달받는 배열을 dependency array라고 하며, 배열에 입력된 ...",
    "content": "ReactEffect Hook  useEffect는 컴포넌트 내에서 Side Effect를 실행할 수 있게 하는 Hook이다.  useEffect는 두 가지 인자를 전달받는데, 첫 번째 인자는 함수이며 두 번째 인자는 언제 배열을 받아 언제 실행될지를 결정한다.  두 번째 인자로 전달받는 배열을 dependency array라고 하며, 배열에 입력된 특정값이 바뀔 때마다 첫 번째 인자인 함수를 실행한다.// 컴포넌트가 처음 생성되거나, props가 업데이트 되거나, state가 업데이트 될 때 실행useEffect(()=&gt;{    console.log(\"첫 번째 인자를 실행합니다.\")})// 컴포넌트가 처음 생성될 때만 실행useEffect(()=&gt;{    console.log(\"첫 번째 인자를 실행합니다.\")},[])// 특정값이 바뀔 때마다 실행useEffect(()=&gt;{    console.log(\"첫 번째 인자를 실행합니다.\")},[dependency])예시  state변경에 따른 경고창 띄우기import React,{useState,useEffect} from \"react\"function Example(){    const [count, setCount] = useState(0)    function countUp(){        setCount(count+1)    }    useEffect(()=&gt;{        if(count &gt; 5){            alert(\"최댓값은 5입니다.\")            setCount(5)        }    },[count])    return (        &lt;div&gt;            &lt;button onClick={countUp}&gt;실행 횟수는{count}입니다.&lt;/button&gt;        &lt;/div&gt;    )}예시 2  API호출 시 로딩화면 띄우기  Loading 컴포넌트import React from \"react\"function Loading(){    return &lt;div&gt;Loading&lt;/div&gt;}export default Loading;  App 컴포넌트          loading이 true 완료된 상태이면 화면에 보여주고, false이면 화면에서 보여지지 않게 처리한다.      fetch가 처리될 때는 loading의 상태를 true로 바꿔주고, fetch가 완료됐을 때는 false로 바꿔준다.      API호출이 완료되기 전까지는 Loading 컴포넌트가 보여진다.      import React,{useState,useEffect} from \"react\"function App(){    const [loading,setLoading] = useState(true)    const miniApi = async() =&gt;{        setLoading(true);        try{            const reponse = await fetch(\"api uri\".{                method: \"POST\",                headers: {                    Accept: \"application/json\",                    \"Context-Type\":\"application/json\"                },body:JSON.stringify(),            })            const result = await response.json();            setLoading(false)        }.catch(error){            window.alert(error);        }    }    useEffect(()=&gt;{        miniApi();    },[])    return (        &lt;div&gt;            {loading ? &lt;Loading /&gt; : null}        &lt;/div&gt;    )}"
  },
  
  {
    "title": "Interview 2장 - 순수함수와 부수효과",
    "url": "/posts/2-Interview-%EC%88%9C%EC%88%98%ED%95%A8%EC%88%98/",
    "categories": "INTERVIEW",
    "tags": "sideeffect, function, pure",
    "date": "2023-02-02 00:00:00 +0900",
    





    
    "snippet": "CSSide Effect(부수효과)  어떤 구현이 함수 외부에 영향을 끼치는 경우를 말한다.  컴포넌트 내에서 fetch를 사용해 API 정보를 가져오거나 이벤트를 활용해 DOM을 조작할 떄 Side Effect가 발생했다고 말한다.  외부 변수를 참조하거나 변경하는 효과이다.let side = \"effect\";function effect() {  s...",
    "content": "CSSide Effect(부수효과)  어떤 구현이 함수 외부에 영향을 끼치는 경우를 말한다.  컴포넌트 내에서 fetch를 사용해 API 정보를 가져오거나 이벤트를 활용해 DOM을 조작할 떄 Side Effect가 발생했다고 말한다.  외부 변수를 참조하거나 변경하는 효과이다.let side = \"effect\";function effect() {  side = \"warning\";}effect();// effect는 Side Effect를 발생시킨다.Pure Function(순수함수)  순수함수란, Side Effect가 없는 불변성을 유지하는 함수이다.  순수함수는 항상 동일한 결괏값을 만들기 떄문에 예측이 가능하고, 예측이 가능한 결과를 반환하기 때문에 순수함수들과의 조합성이 좋아 재사용성이 높다.  순수함수가 아닐 경우, 함수들의 조합성이 떨이져 결과를 예측하기 힘들어지고, 어떠한 값이 여러 함수의 결과에 영향을 주기 때문에 유지보수가 힘들어진다.// 순수함수function example(a, b) {  return a + b;}example(5, 10);// 15// 순수함수가 아닌 경우let c = 10;function example(a, b) {  return a + b + c;}example(5, 10); // 15c = 20;example(5, 10); // 35"
  },
  
  {
    "title": "React 6장 - Lifting State Up",
    "url": "/posts/1-React-useEffect/",
    "categories": "REACT",
    "tags": "router, props, compoents, useeffect",
    "date": "2023-02-02 00:00:00 +0900",
    





    
    "snippet": "React상태끌어올리기  리액트에서의 데이터는 위에서 아래로 흐르는데, 이를 데이터 하향식 흐름이라고 한다.  데이터는 단방향으로 흐르는데, 상위 컴포넌트에서 하위 컴포넌트로 state를 전달할 때 props를 통해 하위 컴포넌트가 이를 전달받고, prop이 어디서 왔는지 쉽게 알 수 있다.  하나의 state를 두 개의 컴포넌트가 사용한다고 했을 때...",
    "content": "React상태끌어올리기  리액트에서의 데이터는 위에서 아래로 흐르는데, 이를 데이터 하향식 흐름이라고 한다.  데이터는 단방향으로 흐르는데, 상위 컴포넌트에서 하위 컴포넌트로 state를 전달할 때 props를 통해 하위 컴포넌트가 이를 전달받고, prop이 어디서 왔는지 쉽게 알 수 있다.  하나의 state를 두 개의 컴포넌트가 사용한다고 했을 때, state를 상위 컴포넌트에 위치시켜 데이터의 흐름을 지켜야 한다.  상태의 위치를 상위 컴포넌트에 위치시켰고 하위 컴포넌트에 의해 상위 컴포넌트의 상태가 변하는 것을 상태끌어올리기라고 한다.  콜백 함수를 호출하듯이, 상태를 변경시키는 함수 자체를 하위 컴포넌트에 prop로 전달한다.예시  상위 컴포넌트에 state와 state를 바꿔줄 함수를 작성한다.      작성한 함수를 하위 컴포넌트에 prop으로 전달한다.    Parents 컴포넌트          상위 컴포넌트에서 state를 작성한다.      함수를 실행시키면 state를 변경시키는데, 실행 함수를 하위 컴포넌트인 Child 컴포넌트의 prop으로 전달한다.      import React, {useState} from \"react\"import Child from \"./Child.js\"function Parents(){    const [changeValue, setChangeValue] = useState(\"처음은 부모의 값\")        function changeValueWithChild(){        setChangeValue(\"자식이 값 바꿔주기\")    }    return (        &lt;div&gt;            &lt;Child valueFunc={changeValueWithChild} /&gt;        &lt;/div&gt;    )}  Child 컴포넌트          Parents 컴포넌트로부터 valueFunc를 prop으로 전달받는다.      전달받은 valueFunc는 Parent 컴포넌트에서 작성된 changeValueWithChild 함수를 담고 있다.      Child 컴포넌트의 button을 누르면 parentsFunctionGo 함수를 실행시키는데, 이 함수는 전달받은 prop인 valueFunc를 실행시킨다.                  Parents 컴포넌트에 전달되어 최종적으로 changeValueWithChild 함수를 실행시킨다.                    Parents 컴포넌트의 state 값이 Child 컴포넌트에 의해 \"자식이 값 바꿔주기\" 로 변경된다.      import React from \"react\"function Child({valueFunc}){    function parentsFunctionGo(){        valueFunc()    }    return (        &lt;button onClick={parentFunctionGO}&gt;부모 값 변경&lt;/div&gt;    )}예시 2  콜백 함수의 인자로 전달하기  Parents 컴포넌트import React,{useState} from \"react\"import Child from \"./Child.js\"function Parents(){    const [changeValue, setChangeValue] = useState(\"하위 컴포넌트의 값이 올 자리\")    function changeValueWithChild(newValue){        setChangeValue(newValue)    }    return (        &lt;div&gt;            &lt;Child valueFunc={changeValueWithChild} /&gt;        &lt;/div&gt;    )}  Child 컴포넌트import React from \"react\"function Child({valueFunc}){    function parentsFunctionGo(){        valueFunc(\"여기에서 값을 변경한다\")    }    return (        &lt;button onClick={}&gt;부모 값 변경&lt;/button&gt;    )}예시 3  Twitter 컴포넌트          작성하는 tweet이 계속 추가된다.      NewTweet, SingleTweet 컴포넌트는 Twitter 컴포넌트의 상태값을 공유한다.      addTweetFunc이 실행되면 기존에 작성된 tweet에 새로 작성한 tweet를 추가한다.                  하위 컴포넌트인 NewTweet에서 작성된 새로운 tweet은 인자인 newTweet으로 전달받는다.                    저장된 tweet는 SingleTweet의 props로 값을 전달해준다.      import React,{useState} from \"react\"import NewTweet from \"./NewTweet.js\"import SingleTweet from \"./SingleTweet.js\"function Twitter(){    const[tweet, setTweet] = useState([        {            id : 1,            writer : \"John\",            date : \"2022-02-20\",            content : \"트위터 추가하기\"        },        {            id : 2,            writter : \"Jane\"            date : \"2022-02-21\",            content : \"트위터 기존 내용\"        }    ])    const addTweetFunc(newTweet){        setTweet([...tweet, newTweet])    }    return (        &lt;div&gt;            &lt;NewTweet addTweet={addTweetFunc} /&gt;            &lt;ul&gt;                {tweet.map((tweetFactor) =&gt; (                    &lt;SingleTweet key={tweetFactor.id}                     writer={tweetFactor.writer}                     date={tweetFactor.date}&gt;{tweetFactor.content}&lt;/SingleTweet&gt;                ))}            &lt;/ul&gt;        &lt;/div&gt;    )}  NewTweet 컴포넌트          상위 컴포넌트인 Twitter에서 전달받은 prop인 addTweet은, 상위 컴포넌트에 작성된 함수인 addTweetFunc을 실행시킨다.      각각 input,textarea에 값이 입력될 때마다 지정된 함수를 통해 writer,textValue의 state를 변경시킨다.      변경된 state를 goAddTweetFunc함수에서 사용하며, 함수는 작성된 newTweet을 다시 상위 컴포넌트에서 작성된 addTweetFunc을 실행시키기 위해 전달된 prop인 addTweet자체를 실행시킨다.                  작성된 tweet은 상위 컴포넌트에 전달인자인 newTweet으로 넘겨준다.                    import React from \"react\"function NewTweet({addTweet}){    const [textValue, setTextValue] = useState(\"\")    const [writer, setWriter] = useState(\"\")    function writerChange(e){        setWriter(e.target.value)    }    function textChange(e){        setTextValue(e.target.value)    }    function goAddTweetFunc(){        let newTweet = {            id : Math.floor(Math.random()*10000),            writer,            date : new Date().toISOString().substring(0,10),            content : textValue        }        addTweet(newTweet)    }    return (        &lt;form onSubmit={goAddTweetFunc}&gt;            &lt;input type=\"text\" onChange={writerChange}&gt;            &lt;textarea onChange={textChange}&gt;&lt;/textarea&gt;            &lt;button type=\"submit\"&gt;새 글 쓰기&lt;/button&gt;        &lt;/form&gt;    )}  SingleTweet 컴포넌트          NewTweet 컴포넌트에서 작성된 새로운 tweet은 상위 컴포넌트인 Twitter에 추가되고 추가된 tweet의 상태를 SingleTweet 컴포넌트가 넘겨받아 이를 토대로 요소를 생성한다.      import React from \"react\"function SingleTweet({writer,date,content}){    return(        &lt;li&gt;            &lt;div&gt;{writer}&lt;/div&gt;            &lt;div&gt;{date}&lt;/div&gt;            &lt;div&gt;{content}&lt;/div&gt;        &lt;/li&gt;    )}"
  },
  
  {
    "title": "React 5장 - Router",
    "url": "/posts/1-React-Router/",
    "categories": "REACT",
    "tags": "react, components, router, ssr, csr, client, server, rendering",
    "date": "2023-01-24 00:00:00 +0900",
    





    
    "snippet": "ReactSPA  Single-Page-Application의 약자이다.  사용자에 요청에 페이지 전체를 바꿔서 보여주는 방식이 아닌 필요한 부분만을 로딩하는 방식이다.  기존 브라우저는 웹페이지를 미리 준비해두었다가, 서버 측에서 데이터를 전달받아 렌더링하는 방식이었다.  규모가 커지고 사용자와의 상호작용이 많아짐에 따라 기존의 서버 방식의 속도 저...",
    "content": "ReactSPA  Single-Page-Application의 약자이다.  사용자에 요청에 페이지 전체를 바꿔서 보여주는 방식이 아닌 필요한 부분만을 로딩하는 방식이다.  기존 브라우저는 웹페이지를 미리 준비해두었다가, 서버 측에서 데이터를 전달받아 렌더링하는 방식이었다.  규모가 커지고 사용자와의 상호작용이 많아짐에 따라 기존의 서버 방식의 속도 저하 문제가 발생했다. 이를 해결하기 위한 것이 SPA방식이다.  CSR방식이다 (SSR과 CSR)Router  사용자가 요청한 URL에 따라 해당 URL에 맞는 페이지를 보여주는 것이다.  여러 라우팅 관련 라이브러리 중 React Router가 가장 많이 사용된다.  리액트 SPA에서는 경로에 따라 다른 뷰를 보여줄 수 있다.  라우터 라이브러리는 크게 세가지로 구분된다.          BrowserRouter : 컴포넌트의 최상위에 작성되어 React Router의 컴포넌트를 활용할 수 있도록 한다.      Routes, Route : 경로를 매칭해주며 Routes 컴포넌트가 경로가 일치하는 하나의 Route만 렌더링한다.      Link : a태그와 비슷한 역할을 하며, Link 컴포넌트를 누르면 화면을 변경시키는 역할을 한다.                  a태그는 페이지 전환 시, 처음부터 렌더링을 시키는 새로고침 현상이 있지만, Link컴포넌트는 페이지 전환을 방지하는 기능이 내장되어 있어 SPA구현에 적합하다.                    Router 사용  npm install react-router-dom --save를 입력하여 Router를 설치한다.  package.json 파일에 dependencies 중 react-router-dom이 있는지 확인한다.  Router 라이브러리를 최상위 컴포넌트에 작성한다.  각 페이지로 이동할 url주소를 입력하고 페이지에 해당하는 컴포넌트들을 연결한다.import React from \"react\"import {BrowserRouter,Routes,Route,Link} from 'react-router-dom'import Home from \"./Home.js\"import MyPage from \"./MyPage.js\"import Board from \"./Board.js\"function App(){    return (        &lt;BrowserRouter&gt;            &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;            &lt;Link to=\"/mypage\"&gt;Mypage&lt;/Link&gt;            &lt;Link to=\"/board\"&gt;Board&lt;/Link&gt;            &lt;Routes&gt;                &lt;Route path=\"/\" element={&lt;Home /&gt;}&gt;                &lt;Route path=\"/mypage\" element={&lt;MyPage /&gt;}&gt;                &lt;Route path=\"/board\" element={&lt;Board /&gt;}&gt;            &lt;/Routes&gt;        &lt;BrowserRouter&gt;    )}예시  index.jsimport React from \"react\"import ReactDOM from \"react-dom\"import App from \"./App.js\"import {BrowserRouter} from \"react-router-dom\"ReactDOM.render(    &lt;BrowserRouter&gt;        &lt;App /&gt;    &lt;/BrowserRouter&gt;    document.getElementById(\"root\"))  Home 컴포넌트import React from \"react\";function Home() {  return (    &lt;div&gt;      &lt;h1&gt;HOME&lt;/h1&gt;    &lt;/div&gt;  );}export default Home;  About 컴포넌트import React from \"react\";function About() {  return (    &lt;div&gt;      &lt;h1&gt;About&lt;/h1&gt;    &lt;/div&gt;  );}export default About;  App 컴포넌트import { Route, Routes } from \"react-router-dom\";import Home from \"./Home.js\";import About from \"./About.js\";function App() {  return (    &lt;Routes&gt;      &lt;Routes path=\"/\" element={&lt;Home /&gt;} /&gt;      &lt;Routes path=\"/About\" element={&lt;About /&gt;} /&gt;    &lt;/Routes&gt;  );}export default App;"
  },
  
  {
    "title": "Interview 1장 - SSR과 CSR",
    "url": "/posts/3-CS-SSR%EA%B3%BC-CSR/",
    "categories": "INTERVIEW",
    "tags": "router, ssr, csr, client, server, rendering",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "CSSSR  Server Side Rendering의 약자이다.  클라이언트측에서 서버의 HTML로 렌더링하는 방식이다.SSR 방식  사용자가 웹 페이지를 방문하면(request), 서버는 리소스를 확인하고 페이지 내에 있는 서버측 스크립트를 실행 후 HTML 컨텐츠를 컴파일 및 준비한다.  컴파일된 HTML을 클라이언트의 브라우저로 전송한다.(res...",
    "content": "CSSSR  Server Side Rendering의 약자이다.  클라이언트측에서 서버의 HTML로 렌더링하는 방식이다.SSR 방식  사용자가 웹 페이지를 방문하면(request), 서버는 리소스를 확인하고 페이지 내에 있는 서버측 스크립트를 실행 후 HTML 컨텐츠를 컴파일 및 준비한다.  컴파일된 HTML을 클라이언트의 브라우저로 전송한다.(response)  브라우저는 HTML파일을 다운로드하고 사용자가 사이트를 볼 수 있게 한다.  그 다음 자바스크립트를 다운로드한다.  사용자가 페이지를 이동할 경우, 페이지에 맞는 HTML과 자바스크립트를 요청,전송하는 방식으로 반복된다.SSR의 장점  초기 페이지 로딩 시간이 빠르다.          렌더링이 준비된 HTML파일을 브라우저에서 로딩하기 떄문에 CSR과 비교하여 더욱 빠르다.        SEO 검색엔진에 친화적이다.          검색엔진은 HTML의 정보를 읽어 결과를 도출하기 떄문에, HTML자체에 정보를 담고 있는 SSR 방식이 친화적이다.      CSR이 빈 HTML파일을 보내고, 필요할 때마다 자바스크립트를 보내 페이지를 로딩하는 방식과의 차이점        클라이언트의 하드웨어 및 소프트웨어 성능에 영향을 덜 받는다.          일반적으로 서버가 더 높은 성능과 네트워킹 속도를 가지고 있는데, 클라이언트에서는 서버에서 완성된 페이지만 렌더링해주면 되기 때문에 클라이언트 측의 부담이 덜하다.      SSR의 단점  페이지를 이동할 때마다 서버에서 페이지를 생성하는 시간이 필요하기 떄문에 TTFB(Time To Frist Byte)가 느리다.  페이지에 로딩해야 할 정보가 많다면 로딩에 필요한 데이터가 많이 필요하기 떄문에 사용자의 경험을 해칠 수 있다.  서버가 HTML 파일과 안에 내용을 생성해야하기 떄문에 서버 호싕이 필요하다.  CSR에 비해 더 많은 개발 노력이 필요하며, 프레임워크 사용 시 추가적인 비용이 발생한다.CSR  클라이언트측에서 웹 페이지를 렌더링하는 방식이다.  모든 로직과 데이터 등을 가져와 클라이언트측에서 처리된다.  CSR은 필요한 자바스크립트만을 사용하기 때문에 적극적으로 코드를 분할하여, 필요한 곳에 필요한 것만 제공할 수 있어야 한다.CSR 방식  사용자가 웹 페이지를 방문하면(request), 브라우저는 최소한의 HTML파일을 다운로드(response)한다.          이 HTML 파일은 script,meta,link 등의 태그를 포함하며, HTML은 빈 파일이라고 보면 된다.        브라우저는 HTML에 있는 자바스크립트 파일을 다운로드하여 AJAX를 통해 API요청을 수행하여 동적 컨텐츠를 가져오고 파싱하여 최종 컨텐츠를 렌더링한다.  사용자가 페이지를 이동할 경우, 서버에 추가 HTML파일을 요청하지 않고 이미 받은 자바스크립트를 이용하여 렌더링한다.CSR 장점  CSR을 위해 모든 지원 스크립트가 사전에 로드되어있기 때문에 로드 시간이 단축된다.  별도의 API를 호출할 필요가 없는 페이지거나, 이미 스크립트가 로딩된 경우 인터넷 없이도 웹 애플리케이션을 실행할 수 있다.  CSR은 서버를 호출할 때마다 전체 UI를 다시 로드할 필요가 없다.CSR 단점  초기 페이지 로드 시간이 SSR에 비해 느리다.          브라우저에서 사용 가능한 컨텐츠로 HTML을 컴파일해야하고 HTML,CSS 등 모든 필수 스크립트를 브라우저에서 로드하여야 하기 시간이 오래 걸린다.        SEO에 친화적이지 않다.          CSR방식은 빈 HTML을 갖고 있기 때문에 검색 엔진이 필요한 정보를 읽어낼 수 없다.      최근에는 많이 개선되었지만, 아직 많은 검색 엔진이 이를 지원하지 않는다.        한 페이지에서 다른 페이지로 이동할 경우, 이를 인지시켜주기 위해 각 페이지에 대한 메타 데이터를 설정해야하고 클라이언트에서 렌더링시키기 위해 추가적인 노력이 필요하다.  브라우저가 페이지를 표시하기 전에 HTML과 자바스크립트 파일을 다운로드하는 동안 사용자는 빈 페이지를 보고 있어야 하기 때문에 사용자 경험(UX)가 좋지 않다.  클라이언트의 하드웨어 및 소프트웨어 성능 의존이 높기 때문에 최적의 시간에 페이지를 렌더링하지 못하는 경우가 발생한다.          이러한 이탈이 높을수록 검색엔진 순위도 낮아진다.      "
  },
  
  {
    "title": "React 4장 - state",
    "url": "/posts/2-React-state/",
    "categories": "REACT",
    "tags": "react, 리액트, map, jsx, usestate, event, state, prop",
    "date": "2023-01-23 00:00:00 +0900",
    





    
    "snippet": "Reactstate  prop가 컴포넌트에 매개변수로 전달되는 역할을 한다면, state는 컴포넌트에 대한 데이터 또는 정보를 포함하는 데 쓰이는 객체이다.  저장된 state는 값이 바귈 때마다 컴포넌트를 다시 렌더링시킨다.  state는 여러 속성을 지정할 수 있으며 useState를 통해 값을 변경(추가,삭제)시키기도 한다.  비동식이다.  re...",
    "content": "Reactstate  prop가 컴포넌트에 매개변수로 전달되는 역할을 한다면, state는 컴포넌트에 대한 데이터 또는 정보를 포함하는 데 쓰이는 객체이다.  저장된 state는 값이 바귈 때마다 컴포넌트를 다시 렌더링시킨다.  state는 여러 속성을 지정할 수 있으며 useState를 통해 값을 변경(추가,삭제)시키기도 한다.  비동식이다.  react에서 useState를 호출해서 사용한다.예시  App 컴포넌트 안에 각각 blue,red의 상태를 지정한다.  useState에 전달되는 값은 blue와red의 초기값을 의미한다.  setState는 blue와red의 상태를 변경한다.  button이 클릭될 떄마다 각각 함수를 실행시키는데, 함수 안에는 state를 변경시킨다.  함수 안에 blue++,red++라고 작성 시, 변수 자체를 변경하는 것으로 취급하여 const에 대한 재할당이 실행된다.  따라서, blue+1,red+1과 같이 작성해주어야 한다.  button에 전달된 onClick은 리액트의 이벤트핸들링으로 클릭했을 때의 실행을 의미한다.import React, {useState} from \"react\"function App (){    \bconst [blue, setBlue] = useState(0)    const [red, setRed] = useState(0)    function bluePlus(){        setBlue(blue+1)    }    function redPlus(){        setRed(red+1)    }    return (        &lt;div&gt;            &lt;div&gt;                &lt;h3&gt;파란색 버튼 클릭 횟수 : {blue}&lt;/h3&gt;                &lt;button onClick={bluePlus}&gt;블루 버튼 증가시키기&lt;/button&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;h3&gt;레드 버튼 클릭 횟수 : {red}&lt;/h3&gt;                &lt;button onClick={redPlus}&gt;레드 버튼 증가시키기&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;    )}예시 2  입력한 글자를 보여주는 기능 구현  보여줄 텍스트\u001d의 상태를 지정한다. =&gt; useState  text의 초기값은 아무것도 지정하지 않은 공백이다.  input버튼을 만들고 버튼의 prop 중 value는 값을 의미하며 input에 입력된 텍스트를 가르킨다. 입력되었을 때 실행되는 이벤트핸들러인 onChange를 작성한다.  onChange에 의해 값이 입력될 때마다 inputValue함수를 실행시키는데, input에 입력되는 값을 e 객체를 전달받는다.  e안에 target이라는 메서드를 통해 이벤트가 발생된 대상을 지칭하며 value는 발생된 대상의 값을 의미한다.          대상의 값은, 이벤트가 발생한 대상 input의 prop 중 value      import React, {useState} from \"react\"function App(){    const [text, setText] = useState('')    function inputValue(e){        setText(e.target.value)    }    return (        &lt;div&gt;            &lt;input type=\"text\" value={text} onChange={inputValue}&gt;            &lt;p&gt;{text}&lt;/p&gt;        &lt;/div&gt;    )}예시 3  삼항연산자를 이용한 상태 변경  changeText의 초기값은 ‘React’이다.  button 안에서 onClick이라는 이벤트핸들러가 발생 시, 바로 함수를 실행시키는데, 이 함수는 changeText값이 ‘React’가 맞다면 ‘Java’라는 값으로 바꾸고, ‘React’가 아니라면 ‘React’로 상태를 바꿔준다setChangeText.import React,{useState} from \"react\"function App(){    const [changeText, setChangeText] = useState(\"React\")    return(        &lt;div&gt;            Change Mode {changeText}            &lt;button onClick={                () =&gt; changeText === \"React\"? setChangeText(\"Java\") : setChangeText(\"React\")            }&gt;change!&lt;/button&gt;        &lt;/div&gt;    )}"
  },
  
  {
    "title": "React 3장 - event",
    "url": "/posts/1-React-event/",
    "categories": "REACT",
    "tags": "react, 리액트, map, jsx, event",
    "date": "2023-01-22 00:00:00 +0900",
    





    
    "snippet": "Reactevent  React 엘리먼트에서 이벤트를 처리하는 방식은 DOM 엘리먼트를 처리하는 방식과 비슷하다.  이벤트는 소문자 대신 카멜 케이스를 사용한다.  JSX를 활용하여 문자열이 아닌 함수로 이벤트 핸들러를 전달한다.// DOM&lt;button onclick=\"activateLasers()\"&gt;    Activate Lasers&lt...",
    "content": "Reactevent  React 엘리먼트에서 이벤트를 처리하는 방식은 DOM 엘리먼트를 처리하는 방식과 비슷하다.  이벤트는 소문자 대신 카멜 케이스를 사용한다.  JSX를 활용하여 문자열이 아닌 함수로 이벤트 핸들러를 전달한다.// DOM&lt;button onclick=\"activateLasers()\"&gt;    Activate Lasers&lt;/button&gt;// React&lt;button onClick={activateLasers}&gt;    Activate Lasers&lt;/button&gt;  React에서는 false로 이벤트를 방지할 수 없으며,반드시 preventDefault를 호출해야 한다.  preventDefault를 사용하여 이벤트의 기본실행(submit은 새로고침)을 막는다.  모든 이벤트 핸들러는 이벤트를 동일하기 처리하기 위해 이벤트 객체를 전달받는다.  전달인자로 입력되는 e는 이벤트 객체를 의미한다.          exampleFunc의 e는 onSubmit을 의미하며, &lt;button&gt;이 submit될 때, 발생한다.      function Example(){    function exampleFunc(e){        e.preventDefault();    }    return (        &lt;form onSubmit={exampleFunc}&gt;            &lt;button type=\"submit\"&gt;SUBMIT&lt;/button&gt;        &lt;/form&gt;    )}예시import React from \"react\"import Header from \"./Header.js\"function App (){    return(        &lt;div&gt;            &lt;Header title=\"React\" onChangeMode={function(){                alert(\"Header\");            }}&gt;&lt;/Header&gt;        &lt;/div&gt;    )}import React from \"react\"function Header(props){    return (        &lt;header&gt;            &lt;h1&gt;                &lt;a href=\"#\" onClick={function(event){                    event.preventDefault();                    props.onChangeMode();}                }&gt;{props.title}&lt;/a&gt;            &lt;/h1&gt;        &lt;/header&gt;    )}export default Header  props로 전달된 { title, onChangeMode }를 props.title, props.onChangeMode 로 작성했다.  a태그의 기본 이벤트인 링크 이동을 preventEvent로 방지하고 경고창을 실행시킨다.예시 2import React from \"react\"import Nav from \"./Nav.js\"function App()  {    const list = [        {id: 1, title: \"html\", body: \"html is\"},        {id: 2, title: \"css\", body: \"css is\"},        {id: 3, title: \"java\", body: \"java is\"},    ]     return (        &lt;div&gt;            &lt;Nav list={list} onChangeMode={(id) =&gt; {                alert(id)            }}&gt;&lt;/Nav&gt;        &lt;/div&gt;     )}import React from \"react\"function Nav(props){    const navList = [];    for(let i=0; i&lt;props.topics.length; i++){        let t = props.topics[i];        navList.push(            &lt;li key={t.id}&gt;                &lt;a id={t.id} href={`/read/` + t.id} onClick={evnet =&gt; {                    event.preventDefault();                    props.onChangeMode(event.target.id)                }}&gt;{t.title}&lt;/a&gt;            &lt;/li&gt;            )    }    return (        &lt;nav&gt;            &lt;ul&gt;                {navList}            &lt;/ul&gt;        &lt;/nav&gt;    )}  App 컴포넌트를 통해 Nav 컴포넌트로 topics 와 onChangeMode 함수를 넘겨준다.  Nav 컴포넌트는 새로 선언된 navList 배열에 for문을 이용하여 li 태그를 삽입한다.  preventDefault로 a 태그의 기본 동작인 ‘새 창 열기’ 를 막고 props로 전달된 onChangeMode를 실행시킨다.  onChangeMode에 전달되는 event.target은 이벤트를 발생시킨 주체를 의미하는데, 이 주체는 a 태그로, a 태그의 id를 불러온다."
  },
  
  {
    "title": "React 2장 - Component와 props",
    "url": "/posts/1-React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-prop/",
    "categories": "REACT",
    "tags": "react, 리액트, map, key, 컴포넌트, jsx",
    "date": "2023-01-21 00:00:00 +0900",
    





    
    "snippet": "React컴포넌트 줄이기function App(){    return (        &lt;div&gt;            &lt;header&gt;                &lt;h1&gt;&lt;a href=\"/\"&gt;WEB&lt;/a&gt;&lt;/h1&gt;            &lt;header&gt;            &lt;na...",
    "content": "React컴포넌트 줄이기function App(){    return (        &lt;div&gt;            &lt;header&gt;                &lt;h1&gt;&lt;a href=\"/\"&gt;WEB&lt;/a&gt;&lt;/h1&gt;            &lt;header&gt;            &lt;nav&gt;                &lt;ol&gt;                    &lt;li&gt;&lt;a href=\"/read/1\"&gt;html&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=\"/read/2\"&gt;css&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=\"/read/3\"&gt;js&lt;/a&gt;&lt;/li&gt;                &lt;/ol&gt;            &lt;nav&gt;            &lt;article&gt;                &lt;h2&gt;WELCOME&lt;/h2&gt;                Hello,WEB            &lt;/article&gt;        &lt;/div&gt;    )}  Header 컴포넌트import React from \"react\"function Header(){    return (        &lt;header&gt;            &lt;h1&gt;header 컴포넌트입니다.&lt;/h1&gt;        &lt;/header&gt;     )}export default Header  Nav 컴포넌트import React from \"react\"function Nav(){    return(        &lt;nav&gt;            &lt;ol&gt;                &lt;li&gt;                    &lt;a hre=\"#\"&gt;예시 링크1&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a hre=\"#\"&gt;예시 링크2&lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;a hre=\"#\"&gt;예시 링크3&lt;/a&gt;                &lt;/li&gt;            &lt;/ol&gt;        &lt;/nav&gt;    )}export default Nav  Article 컴포넌트import React from \"react\"function Article (){    return (        &lt;article&gt;            &lt;h2&gt;Hi&lt;/h2&gt;            example Hi        &lt;/article&gt;    )}export default Article  완성 코드import React from \"react\"import Header from \"./Header.js\"import Nav from \"./Nav.js\"import Article from \"./Article.js\"function App (){    return (        &lt;div&gt;            &lt;Header&gt;&lt;/Header&gt;            &lt;Nav /&gt; {/*한 줄로 축약 가능*/}            &lt;Article /&gt;        &lt;/div&gt;    )}const root = ReactDOM.createRoot(document.getElementById(\"root\"));root.render(&lt;App /&gt;);prop  컴포넌트에 어떠한 함수나 값을 전달할 때 사용하는 속성이다.  리액트는 단방향 데이터 흐름을 갖고 있으며, 상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용한다.  자식 컴포넌트에서 prop을 수정할 수 없는 읽기 전용 데이터이다.  한 개의 prop은 그대로 전달할 수 있고, 여러 개의 prop은 비구조화 할당 문법을 사용하여 전달한다.import React from \"react\"function App(){    const list = [        id: \"Sara\",        gender: \"female\"    ]    return (        &lt;div&gt;            &lt;Header transmit={list}/&gt;            &lt;Nav transmit={list}/&gt;            &lt;Article /&gt;        &lt;/div&gt;    )}  Header 컴포넌트          transmit이라는 prop으로 하위 컴포넌트에게 list를 넘겨준다.      전달받은 transmit을 통해 상위 컴포넌트의 list배열에 접근할 수 있다..      App 컴포넌트의 list를 임의의 prop명인 props로 전달받는다.      list 배열에 id를 출력한다.      import React from \"react\"function Header (props){    return(        &lt;header&gt;            &lt;h1&gt;{props.id}&lt;/h1&gt;        &lt;/header&gt;    )}export default Header  map() 활용하기          Header 컴포넌트에 map()을 활용하여 데이터를 펼칠 수 있다.      import React from \"react\"function App(){    const list = [        {id: \"Sara\",        gender: \"female\"},        {id: \"Mike\",        gender: \"male\"},        {id: \"John\",        gender: \"male\"},    ]    return (        &lt;div&gt;            &lt;Header transmit={list}/&gt;            &lt;Nav transmit={list}/&gt;            &lt;Article /&gt;        &lt;/div&gt;    )}import React from \"react\"function Header ({props}){    return(        &lt;header&gt;            {props.map(el =&gt; (                &lt;div key={el.id}&gt;                    &lt;h1&gt;{el.id}&lt;/h1&gt;                    &lt;p&gt;{el.gender}&lt;/p&gt;                &lt;/div&gt;            ))}        &lt;/header&gt;    )}export default Header"
  },
  
  {
    "title": "React 1장 - 기초",
    "url": "/posts/1-React-%EA%B8%B0%EC%B4%88/",
    "categories": "REACT",
    "tags": "react, 리액트, map, key, 컴포넌트, jsx",
    "date": "2023-01-20 00:00:00 +0900",
    





    
    "snippet": "React  리액트는 HTML/CSS/JS로 나눠적기보다 하나의 파일에 명시적으로 작성할 수 있게 JSX를 활용한 선언형 프로그래밍을 지향한다.  하나의 기능을 구현하기 위해 여러 종류의 코드를 묶어둔 컴포넌트 를 사용한다.  컴포넌트를 분리하면 서로 독립적이고 재사용성이 높아 기능 자체에 집중할 수 있다.  JavaScript 라이브러리이기 때문에 ...",
    "content": "React  리액트는 HTML/CSS/JS로 나눠적기보다 하나의 파일에 명시적으로 작성할 수 있게 JSX를 활용한 선언형 프로그래밍을 지향한다.  하나의 기능을 구현하기 위해 여러 종류의 코드를 묶어둔 컴포넌트 를 사용한다.  컴포넌트를 분리하면 서로 독립적이고 재사용성이 높아 기능 자체에 집중할 수 있다.  JavaScript 라이브러리이기 때문에 기존 프로젝트에 유연하게 적용할 수 있다.  Facebook에서 개발한 언어로, 안정적이고 유명하며 리액트 네이티브로 모바일 개발도 가능하다.  DOM과 달리 CSS와 JSX만 사용하여 웹 애플리케이션을 개발할 수 있다.  JavaScript만으로 마크업 형태의 코드를 작성하여 DOM에 배치하는 방식이다.  JSX 없이도 React 요소를 만들 수 있지만 코드가 복잡하고 가독성이 떨어진다.import React from \"react\"// React를 불러온다.// 어떠한 파일을 가져올 때(연동)에 사용한다.function App (){    const user = {        firstName : \"React\",        lastName : \"JSX Activity\"    }    function formatName (user){        return user.firstName + \" \" + user.lastName;    }    // JSX 없이 활용한 React    return React.createElement(\"h1\", null, `Hello, ${formatName(user)}!`)    // h1 - 태그 이름 삽입    // null - 넣을 객체 props    // ${formatName(user)} - 자식으로 넣을 요소    // React라는 컴포넌트에 요소를 생성하는데, 무엇을 넣을지}export default App;JSX  JavaScript XML의 줄임말로 JavaScript를 확장한 문법이다.  브라우저가 바로 실행할 수 있는 코드가 아니기 때문에 Babel을 사용하여 브라우저가 이해할 수 있는 JavaScript로 컴파일해야 한다.          리액트에서 따로 모듈을 설치하지 않아도 자동으로 설치한다.        JavaScript를 브라우저가 읽고 화면에 렌더링한다.  엘리먼트 클래스 사용 시, className으로 표기해야 한다.  변수명, 함수 사용을 위해 꼭 중괄호{}로 감싸주어야 한다.  사용자가 정의할 컴포넌트는 꼭 대문자로 시작해야 하며, 소문자로 시작할 경우 일반적인 html 엘리먼트로 인식한다.  if문은 사용이 불가능하며, 삼항연산자를 사용해야 한다.  여러 개의 엘리먼트를 생성할 때는 map() 을 사용해야 한다.          리액트에서 중복되는 요소를 생성할 때는 key 속성이 필요하다.      리액트가 실행되며 사용자의 행동에 의해 요소가 추가되거나 수정,삭제되는 경우가 발생하는데 이때, 리액트가 요소들을 새로 생성하지 않고 기존의 요소를 기억하여 최소한의 수정,복제 등을 한다.      // 틀린 예제 - 여러 개의 요소는 하나의 요소로 감싸주어야 한다.&lt;div&gt;Hi&lt;/div&gt;&lt;div&gt;there&lt;/div&gt;// 올바른 예제&lt;div&gt;    &lt;div&gt;Hi&lt;/div&gt;    &lt;div&gt;there&lt;/div&gt;&lt;/div&gt;// 틀린 예제 - JSX에서 클래스명을 선언 시 class가 아닌 className을 사용해야 한다.&lt;div class=\"example\"&gt;예제입니다.&lt;/div&gt;// 올바른 예제&lt;div className=\"example\"&gt;예제입니다.&lt;/div&gt;// 틀린 예제 - 컴포넌트 선언은 대문자로 시작해야 한다.function app(){    ***}// 올바른 예제function App(){    ***}  예제const posts = [  { id: 1, title: \"Hello World\", content: \"Welcome to learning React\" },  { id: 2, title: \"Installation\", content: \"You can install React from npm\" }];// 함수형 컴포넌트, 컴포넌트를 export default로 기본값으로 넘겨준다.export default function App(){    // 선언형 컴포넌트    const postJSX = (post) =&gt; {        // 전달받는 인자가 post이다.        return (            &lt;div key={post.id}&gt;                &lt;h3&gt;{post.title}&lt;/h3&gt;                &lt;p&gt;{post.content}&lt;/p&gt;            &lt;/div&gt;        )    }    return (        &lt;div&gt;            {post.map(postJSX)}            {/*post의 내용이 postJSX 함수로 인자에 뿌려진다.*/}        &lt;/div&gt;    )}  map을 이용한 반복          100개의 정보를 담은 객체가 있고, 이를 하드코딩한다면, 모든 데이터가 보여질 수 있도록 하나하나 작성해주어야 하지만, map을 이용하여 손쉽게 작성할 수 있다.      const posts = [    { id : 1, title : 'Hello World', content : 'Welcome to learning React!' },    { id : 2, title : 'Installation', content : 'You can install React via npm.' },    { id : 3, title : 'reusable component', content : 'render easy with reusable component.' },    // ...    { id : 100, title : 'I just got hired!', content : 'OMG!' },  ];const App = () =&gt; {    const mapEx = (post) =&gt;{        return (            &lt;div key={post.id}&gt;                &lt;h2&gt;{post.title}&lt;/h2&gt;                &lt;span&gt;{post.content}&lt;/span&gt;            &lt;/div&gt;        )    }    return(        &lt;div&gt;            {posts.map(mapEx)}        &lt;/div&gt;        {/* 또는 posts.map(mapEx) 자체를 변수로 선언하여 변수 자체를 넣어줄 수 있다.*/}    )}  key 속성          리액트에서 반복되는 요소를 처리할 때 key 속성이 필요하며, key가 없어도 작동은 가능하지만 리액트가 효율적으로 작동하기 위해서는 key 속성이 필요하다. (JSX \b설명 참조)      key 속성값은 가능한 데이터에서 제공하는 id가 할당되어야 한다.      id가 없는 경우 인덱스를 넣어서 해결할 수 있지만, 최후의 수단으로 사용해야 한다.      Component  하나의 기능 구현을 위한 여러 종류의 코드들을 묶어 놓은 것이다.  UI를 구성하는 필수 요소이다.  리액트의 심장이라고도 불리우며, 각각 독립적인 기능을 가지고 있는 UI의 한 부분으로, 이를 조합하여 애플리케이션을 만든다.  리액트 애플리케이션은 최소 한 개의 컴포넌트를 가지고 있다.  최상위 컴포넌트는 근원의 역할을 하며, 여러 개의 자식 컴포넌트를 가질 수 있고, 이러한 계층적구조가 트리 구조를 형상화한다.  각 컴포넌트는 독립적으로 존재하기 때문에, 하나의 컴포넌트의 기능을 변경한다고 하여 다른 컴포넌트를 수정할 필요가 없다.          원하는 수정사항에 맞춰 컴포넌트의 위치만 수정하거나 재사용할 수 있다.      "
  },
  
  {
    "title": "JavaScript 3장 - 변수와 할당",
    "url": "/posts/2-JavaScript-%EB%B3%80%EC%88%98%EC%99%80-%ED%95%A0%EB%8B%B9/",
    "categories": "JAVASCRIPT",
    "tags": "javascript, 변수, 할당, 백틱, 카멜케이스, 템플릿리터럴, 식별자, 예약어, 재할당",
    "date": "2022-12-16 00:00:00 +0900",
    





    
    "snippet": "변수와 할당  구구단 예시    console.log( 2 * 1 ); // 2console.log( 2 * 2 ); // 4console.log( 2 * 3 ); // 6console.log( 2 * 4 ); // 8console.log( 2 * 5 ); // 10console.log( 2 * 6 ); // 12console.log( 2 * 7 );...",
    "content": "변수와 할당  구구단 예시    console.log( 2 * 1 ); // 2console.log( 2 * 2 ); // 4console.log( 2 * 3 ); // 6console.log( 2 * 4 ); // 8console.log( 2 * 5 ); // 10console.log( 2 * 6 ); // 12console.log( 2 * 7 ); // 14console.log( 2 * 8 ); // 16console.log( 2 * 9 ); // 19        2단에 대한 구구단을 바꾸기 위해 숫자 2를 모두 3으로 바꿔 줘야 하는 번거로움이 있다.  이를 변수에 할당하여 간단하게 해결한다.    let num = 3console.log( num * 1 ); // 3console.log( num * 2 ); // 6console.log( num * 3 ); // 9console.log( num * 4 ); // 12console.log( num * 5 ); // 15console.log( num * 6 ); // 18console.log( num * 7 ); // 21console.log( num * 8 ); // 24console.log( num * 9 ); // 27        = 연산자는 등호 기호가 아닌 할당 연산자를 의미한다.          메모리 공간에 특정한 값을 넣는 것을 할당이라고 한다.      변수명이 가진 메모리 공간을 확보하고, 이 메모리에는 값이 저장되어 있음을 의미한다.        let num; // 변수 선언num = 6; // 값의 할당// let num = 6; 는 변수 선언과 값의 할당이 동시에 이루어진 것이다.-console.log( num * 1 ); // 6console.log( num * 2 ); // 12console.log( num * 3 ); // 18console.log( num * 4 ); // 24console.log( num * 5 ); // 30console.log( num * 6 ); // 36console.log( num * 7 ); // 42console.log( num * 8 ); // 48console.log( num * 9 ); // 54                      값의 재할당          var 키워드드로도 변수를 선언할 수 있지만, 전역 변수로 선언되어 사이드 이펙트를 일으키기 때문에 잘 사용하지 않는다.      let 키워드로 선언한 변수에 새로운 값을 할당한다.      이를 재할당이라고 하며, 재할당 시에도 = 연산자를 사용한다.      const 는 재할당이 불가능하다.        let numA = 6; // 변수 선언과 값의 할당console.log(numA * 1); // 6numA = 7; // 값의 재할당console.log(numA * 1); // 7-const numB = 0;numB = 1 // error                      변수명 규칙          식별자는 특수문자를 제외한 문자, 숫자, 언더스코어 _, 달러 기호 $ 를 포함할 수 있다.      단, 식별자는 숫자를 제외한 문자, 언더스코어 _, 달러 기호 $ 로 시작해야 한다.      예약어 (함수에서 사용되는 메서드) 식별자로 사용할 수 없다.      하나 이상의 단어를 사용할 때는 네이밍 컨벤션을 지켜 가독성을 높인다.      일반적으로 카멜케이스(camelCase)를 사용한다.        let name, $head, _score // 사용 가능 변수명-let 1st; // 변수 사용 불가-let const; // 변수 사용 불가-//변수의 존재 목적을 이해할 수 없는 변수명let x = 100;let y = 50;-//변수의 존재 목적을 명확히 알 수 있는 변수명let name = 'kim';let age = '25';-// 카멜 케이스let firstName = 'girang';let lastName = 'choi';-// 그 밖에 네이밍 컨벤션let first_name; // 스네이크 케이스(snake_case) : 단어와 단어 사이에 언더스코어 사용let FistName; // 파스칼 케이스(PascalCase) : 단어의 시작을 대문자로 작성                      변수 활용          변수에 숫자 타입의 값이 할당되어 있는 경우 모든 연산자를 사용할 수 있다.      연산의 결과를 변수에 재할당 할 수 있다.        let num = 3;console.log(num + 1); // 4console.log(num / 1); // 3console.log(num % 2); // 1-// 변수의 재할당을 활용한 연산 값 대입let num = 3;num = num + 2;console.log(num); // 5                      템플릿 리터럴          백틱을 사용하여 문자열 내부에 변수를 삽입할 수 있다.      템플릿 리터널 내부에 ${ }를 사용하여 변수를 삽이할 수 있으며, 문자열이 할당되지 않은 변수도 문자열로 취급한다.      단어와 단어 사이에 공백을 삽입해야 하는 경우, 백틱을 사용하는 것보다 템플릿 리터럴을 사용하는 것이 가독성 측면에서 우수하다.        //템플릿 리터럴let name = 'kim';let age = '25';let location = 'seoul';console.log('${name} ${age} ${seoul}'); // 'kim 25 seoul' --&gt; 25는 문자열로 취급된다.-//템플릿 리터럴 사용 안할 시let name = 'lim';let age = '22';let location = 'seoul';console.log(name + ' ' + age + ' ' + location); // 'lim 22 seoul'                    "
  },
  
  {
    "title": "JavaScript 2장 - 타입과 변수",
    "url": "/posts/1-JavaScript-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%B3%80%EC%88%98/",
    "categories": "JAVASCRIPT",
    "tags": "javascript, console, type, number, boolean, string, math, index, let, const, var",
    "date": "2022-12-16 00:00:00 +0900",
    





    
    "snippet": "자바스크립트 타입  number  string  booleanNumber  자바스크립트에서 숫자를 표기하기 위한 데이터 타입이며 정수와 실수를 모두 표현할 수 있다.    100;-100;100.1;        typeof 연산자로 해당 값이 숫자 타입인지 알 수 있다.    typeof 100; // 'number'typeof -100; // 'n...",
    "content": "자바스크립트 타입  number  string  booleanNumber  자바스크립트에서 숫자를 표기하기 위한 데이터 타입이며 정수와 실수를 모두 표현할 수 있다.    100;-100;100.1;        typeof 연산자로 해당 값이 숫자 타입인지 알 수 있다.    typeof 100; // 'number'typeof -100; // 'number'typeof 100.1; // 'number'        같은 숫자 값 간에는 사칙연산이 가능하다. (+,-,*,/,%) 이러한 숫자 기호를 산술 연산자라고 부른다.    console.log(1 + 2); // 3console.log(1 - 2); // -1console.log(1 * 2); // 2console.log(1 / 2); // 0.5console.log(2 % 2); // 0        Math 내장 객체          Math.floor() : 괄호 안의 숫자를 내림하여 반환한다.      Math.ceil() : 괄호 안의 숫자를 올림하여 반환한다.      Math.round() : 괄호 안의 숫자를 반올림하여 반환한다.      Math.abs() : 괄호 안의 숫자의 절댓값을 반환한다.      Math.sqrt() : 괄호 안의 숫자의 루트값을 반환한다.      Math.pow() : 괄호 안의 첫 번쨰 숫자를 밑, 두 번째 숫자를 지수인 숫자로 반환한다.        Math.floor(100.1); // 100Math.ceil(100.1); // 101Math.round(100.6); // 101Math.abs(-100); // 100Math.sqrt(4); // 2Math.sqrt(2); // 1.41421356237...Math.pow(2, 5); // 32 2의 5제곱                    String  자연어를 JavaScript에서 표현하기 위한 데이터 타입으로, 따옴표(‘),쌍따옴표(“),백틱(`)으로 감싸면 된다.  맥북의 경우 백틱은 Alt+~ 을 누르면 입력할 수 있다.  한자나 이모지 또한 문자열로 만들 수 있고 숫자와 문자 조합도 가능하다.  백틱으로 만든 문자열은 줄바꿈도 가능하다.    '사과'\"JavaScript\"`Java`        +로 문자열을 이어붙일 수 있다. 문자열과 문자열을 이어붙일 때는 문자열 연결 연산자로 쓰이며, 다른 타입과 이어붙이려고 하면 모두 문자열로 변환한다.    \"안녕하세요\" + \"!!\" // 안녕하세요!!'감사합니다' + ' ' + '~' // 감사합니다 ~1 + '1' // 11문자        문자열의 length 속성을 이용하여 문자열의 길이를 확인할 수 있다.  문자열 값에 .length 를 붙이면 된다.    let str = 'string'console.log(str.length) // 6        문자열의 각 문자는 순서를 가지고 있는데 각 문자가 몇 번째 위치하는지 인덱스(index)로 확인할 수 있다. 첫 번째 문자의 인덱스는 []이며, 이를 Zero-based numbering이라고 한다.    let str = 'student'console.log(str[1]) // 't'console.log(str[5]) // 'n'        toLowerCase() : 문자열을 소문자로 변경한다.  toUpperCase() : 문자열을 대문자로 변경한다.  concat() : 문자열 연결 연산자 + 처럼 문자열을 이어붙일 수 있다.  slice() : 문자열의 일부를 자를 수 있다.    let lowerStr = 'banana'lowerStr.toUpperCase() // 'BANANA'-let upperStr = 'APPLE'upperStr.toLowerCase() // 'APPLE'-let str = 'under'let concatStr = 'BAY'str.concat(concatStr) // 'underBAY'-let sliceStr = 'BANANA'sliceStr.slice(0,-1) // 'BANAN'sliceStr.slice(0) // 'BANANA'sliceStr.slice(1) // 'ANANA'sliceStr.slice(0,3) // 'BANA'        indexOf          문자열이나 배열의 인덱스를 나타낸다.      특정 문자나 값이 문자열이나 배열 안에 있는지 찾을 때도 활용할 수 있다.      일치하는 문자나 값이 없을 경우 -1을 리턴한다.        let str = 'GaNaDaRaMaBaSa'str.indexOf(3) // 'a'str.indexOf('T') // -1                      includes          문자열 내에 특정 문자나 문자가 포함되어 있는지 확인한다.      문자가 있으면 true, 문자가 없으면 false 를 리턴한다.        let str = 'ABCDE'str.includes('A') // truestr.includes('a') // false                    boolean  사실 관계를 구분하기 위한 타입으로 true 나 false 를 리턴한다.          비교연산자로 두 값이 같은지 다른지를 확인할 때 유용하다.      값은 아니지만 false로 여겨지는 값을 falsy, 반대로 true 값은 truthy 라고 하는데, truthy 값은 매우 많아 falsy 값을 외우는 것이 좋다.        false0-00n\"\"''``nullundefinedNaN                      === , !==          엄격한 동치 연사자로 두 피연산자 값과 타입이 같으면 true, 다르면 false 를 리턴한다.      값이 같아도 타입이 다르면 false 를 리턴한다.      원시형이 아닌 참조값은 주솟값도 확인하기 때문에 배열이나 객체의 값이 같아도 주솟값이 다르면 false를 리턴한다.        123 === (100+23); // true123 === '123'; // false123 !== '123'; // true123 !== (100+23); // false-let arrA = [1,2,3]let arrB = [1,2,3]arrA === arrB // false                      == , !=          느슨한 동치 연산자로 대체로 값이 같으면 true 를 리턴한다.      타입이 달라도 값이 같으면 대체로 같은 것이라 취급한다.      느슨하게 여부를 판단하기 때문에 사용하지 않는 것을 권장한다.        12 != '12' // true                      &gt;=,&lt;=,&gt;,&lt;          비교연산자로 대소 관계를 판별하며 수학에서의 부등호 기호와 유사하다.        100 &gt; 200; // false100 &lt; 200; // true100 &gt;= 100; // true200 &lt;= 100; // false                      &amp;&amp;,||          논리연산자로 || 는 OR의 의미를 가져 두 값 중 하나라도 맞다면 true , &amp;&amp; 는 AND의 의미를 가져 두 값 중 하나라도 다르면 false 를 리턴한다.        ture || false; // truefalse || true; // true100 &gt; 200 || 200 &gt; 100; // true-true &amp;&amp; true; // true200 &gt; 100 &amp;&amp; 300 &gt; 200; // true100 &gt; 200 &amp;&amp; 100 &gt; 50; // false                      !          사실 관계를 반대로 표현한다.        !true // false!false // true!0 // true!NAN // true!1 // false                    "
  },
  
  {
    "title": "JavaScript 1장 - 기본 개념",
    "url": "/posts/JavaScrirpt-%EA%B8%B0%EC%B4%88/",
    "categories": "JAVASCRIPT",
    "tags": "javascript, console, var, const, let",
    "date": "2022-12-15 00:00:00 +0900",
    





    
    "snippet": "자바스크립트  자바스크립트는 콘텐츠를 동적으로 바꾸고 멀티미디어를 제어하는 등의 다양한 기능을 하는 프로그래밍 언어이다.  자바스크립트는 html/css와 함께 사용하지만 Node.js를 사용하여 독립적으로 사용이 가능하다.  Java와는 엄연히 다른 프로그래밍 언어로, 브라우저뿐만 아니라 Node.js, REPL 등 다양한 환경에서 사용이 가능하다....",
    "content": "자바스크립트  자바스크립트는 콘텐츠를 동적으로 바꾸고 멀티미디어를 제어하는 등의 다양한 기능을 하는 프로그래밍 언어이다.  자바스크립트는 html/css와 함께 사용하지만 Node.js를 사용하여 독립적으로 사용이 가능하다.  Java와는 엄연히 다른 프로그래밍 언어로, 브라우저뿐만 아니라 Node.js, REPL 등 다양한 환경에서 사용이 가능하다.자바스크립트 실행 방식  자바스크립트는 코드를 위에서 아래로 읽고 해석하며 에러를 발견하는 해당 지점에서 코드를 즉시 중단한다.  브라우저, 서버, 모바일, 개발 등 전범위적인 개발이 가능한 프로그래밍 언어이다.  주석을 추가하여 코드 위 메모가 가능하다.코드 정리  console.log( )          개발자 도구 콘솔이나 터미널에 원하는 값을 출력할 수 있게 도와주는 메서드이다.        // 슬래시를 이용한 주석처리console.log('hello World') // 'hello World'console.log(2) // 2                      let          변수 선언, 하나의 값을 저장한 이름이다.        const          let 과 달리 재할당 (변수에 저장된 값을 다른 값으로 변경)이 불가능하다        let school = 'student'school = 'adult'console.log(school) // 'adult'-const student = 'teacher'student = 'adult' // error                      var          let과 const 같이 변수를 선언하는 용도로 사용되지만 전역 변수로 선언되기 때문에 잘 사용되지 않는다.      "
  }
  
]

